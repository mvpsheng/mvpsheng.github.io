<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我如何应对我正在经历的困难</title>
    <url>/2022/11/09/%E6%88%91%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%88%91%E6%AD%A3%E5%9C%A8%E7%BB%8F%E5%8E%86%E7%9A%84%E5%9B%B0%E9%9A%BE/</url>
    <content><![CDATA[<h1 id="Hello-World！"><a href="#Hello-World！" class="headerlink" title="Hello World！"></a>Hello World！</h1><h2 id="我目前的状况"><a href="#我目前的状况" class="headerlink" title="我目前的状况"></a>我目前的状况</h2><p>目前我在杭州，没有固定的居住地，每天需要寻找一个安静的能提供我进行面试准备的环境。 一方面我可以改简历，一方面我可以准备项目。我解决了居住地的问题，我打算这几天都住在这个安静的、让我舒服的青年旅舍。 我有时间和空间来做我想做的事情。我没有找其他的也许可以很快开始的，同时也足够让我生活在这个城市的工作。因为我觉得我具备去做我专业技能相关工作的能力。我觉得我具备很强的逻辑推理能力，思维敏捷，可以去解决很复杂的问题。我想要通过靠做软件开发的工作来生活。因为做软件开发的工作会让我觉得很兴奋，我对于这件事情很有激情。我为此做了很多准备。但是目前我没有得到什么机会。</p>
<h2 id="做这个博客的目的"><a href="#做这个博客的目的" class="headerlink" title="做这个博客的目的"></a>做这个博客的目的</h2><p>我觉得我现在头脑里面有很多想法，所以我打算搭建这个博客，一个我愿意经常使用的博客，而不是直接可以去发布的像CSDN。这是不一样的体验，这个平台是我自己给自己搭建起来的，我可以选择自己的主题，选择自己的编辑器。可以让我感觉自己在像一个专业的人在工作一样。</p>
<h2 id="我对公司的期待"><a href="#我对公司的期待" class="headerlink" title="我对公司的期待"></a>我对公司的期待</h2><p>工作内容：有创造性的，有挑战的工作。<br>公司文化：我想要公司的团队成员能够有很融洽的关系， 很强的合作意识和逻辑思维能力。<br>包容的，多元的，团队合作的。</p>
<p>这个文章需要拓展， 第一篇文章要写的内容是 我为什么要搭建这个博客。 以及我想要写那些内容。</p>
]]></content>
      <tags>
        <tag>思路总结</tag>
      </tags>
  </entry>
  <entry>
    <title>对于做项目的理解</title>
    <url>/2022/11/09/%E5%AF%B9%E4%BA%8E%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="如何开始一个项目"><a href="#如何开始一个项目" class="headerlink" title="如何开始一个项目"></a>如何开始一个项目</h2><p>构建一个项目， 不意味着从头开始一行一行的写一个项目，也许可以复制大量的代码（但是需要理解代码作用），也许可以在这个原有项目的基础上增加一些新的模块，再或者可以对源代码进行修改或删除一些旧代码同时增加一些新代码。</p>
]]></content>
      <tags>
        <tag>软件开发理解</tag>
      </tags>
  </entry>
  <entry>
    <title>self introduction</title>
    <url>/2022/11/09/self-introduction/</url>
    <content><![CDATA[<h1 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h1><h2 id="我在干什么"><a href="#我在干什么" class="headerlink" title="我在干什么"></a>我在干什么</h2><p>我在找工作，目前的意向岗位是软件开发、后端开发。</p>
<h2 id="我的技术生涯"><a href="#我的技术生涯" class="headerlink" title="我的技术生涯"></a>我的技术生涯</h2><p>我的技术学习主要是在大学和大学毕业后，自学。<br>我主要学习的技术栈是后端开发相关的。<br>编程语言：Java<br>框架：Spring、SpringBoot、SpringCloud、MyBatis<br>数据库：MySQL、MongoDB、Redis</p>
<h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><p>主要是基于SpringBoot开发的项目，比较喜欢做工具相关的项目。这样的项目目的是可以方便我学习或者自我提升的工具。</p>
<p>TODO-List（规划每天要干什么）、 AlgorithmDesignCanvas</p>
<h2 id="我的学习方法和途径"><a href="#我的学习方法和途径" class="headerlink" title="我的学习方法和途径"></a>我的学习方法和途径</h2><p>我的思想是通过多种途径（多种资源和多个人）学习，可以增强我对于一个概念的理解。<br>通过更多的练习，可以让我对于一些技术有更熟练的应用能力。</p>
<p>对标以上两个理念，我产生了我的方法，以及我怎么找资源。</p>
<p>我通过看官方文档学习Spring（因为很细节、很全面、还有一些上手的例子）<br>我会通过看视频学习，Coursera上课，github仓库找项目、Google看一些文档或者概念</p>
<h2 id="我的职业规划"><a href="#我的职业规划" class="headerlink" title="我的职业规划"></a>我的职业规划</h2><p>两到三年之内，我规划是广度优先扩展，希望自己对这个行业有更多的学习、认知和尝试。<br>三年之后，深度优先，对于行业有自己的清晰的发展方向，开始深入研究，希望有所贡献。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>我认为很多事情是相互产生影响的。比如我在旅行的过程中，我会有很多想法在大脑浮现出来。我会对很多事情有一些更深入的思考，或者有一些新的想法。</p>
<h2 id="内容创作"><a href="#内容创作" class="headerlink" title="内容创作"></a>内容创作</h2><p>通常我会把自己的一些想法记录下来，不同的阶段会有不同的工具去记录。<br>在家的时候，有时会写在日记本上。 还有很多会记录在手机的便签上。也有一些会记录在github、其他的手机笔记本上，电脑的便签上。我觉得这样记录很零散，不便于之后查找一些信息，所以我决定专注于自己这个Github博客上，进行内容创作。</p>
<p>平时的一些想法 小的点子会记录在手机便签里。最后都整理在这个博客里。</p>
<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>我喜欢旅行，因为我在离开一个地方的时候，我会有很多想法浮现出来，我通常会在交通工具上思考，并记录一些内容。<br>我喜欢看山水，喜欢自然风光。</p>
<h2 id="运动健身"><a href="#运动健身" class="headerlink" title="运动健身"></a>运动健身</h2><p>篮球，各种球类<br>街头健身</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2>]]></content>
      <tags>
        <tag>我</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习编程</title>
    <url>/2022/11/09/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>你的大脑就是一块肌肉，学习编程就好像健身，需要持续性的、不断重复的练习。 持续性很重要。</p>
<p>第二个就是渐进式学习。</p>
<h2 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h2><p>学习一个新的概念，是因为它好用，用它可以节省时间，可以节省体力，它可以让系统消耗更小，可以有更快的响应时间等，总之就是为了能够应用并能带来好处。</p>
<p>那么学习编程的一些概念就是为了理解，并应用到自己的场景中。</p>
<p>首先入手 概念，这个名词，是什么，为什么产生，为什么用。<br>懂了概念之后，learn by doing！开始着手怎么用，如何应用到自己的场景中。</p>
]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何掌握一个技能</title>
    <url>/2022/11/09/%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E4%B8%80%E4%B8%AA%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>掌握一个技巧之前，状态是要么完全不会，要么不完全会。<br>不断的重复练习，目的是暴露并发现自己不会、不懂的地方，对这些地方学习，或改正，在下一次练习的时候去避免。<br>避免之前犯过的错误，分析为什么出现这个错误，正确的是什么样子。<br>Ever tried， ever failed.<br>No Matter. Try again, fail again. Fail better.<br>重复的练习的生命周期：<br>练习-&gt;暴露问题-&gt;改善问题，避免相同错误-&gt;从而不断减少错误-&gt;从而逐渐熟练。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>应用是目标。 为了能够应用，而去掌握一门技能。<br>学习游泳不是为了学会游泳，而是为了游泳。<br>学习编程不是为了会解决两数之和的问题，不是为了写hello，world。而是用编程去计算出一个问题，设计一个网页，做一个产品。<br>所以学会一些技能之后要去用。</p>
]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>what is &amp; how to use kubernetes</title>
    <url>/2022/11/10/what-is-how-to-use-kubernetes/</url>
    <content><![CDATA[<h2 id="what-is-kubernetes"><a href="#what-is-kubernetes" class="headerlink" title="what is kubernetes"></a>what is kubernetes</h2><p>k8s 是一个用来自动部署，扩展和管理容器化的应用的开源系统。</p>
]]></content>
      <tags>
        <tag>技术研究</tag>
      </tags>
  </entry>
  <entry>
    <title>what is &amp; how to use Docker</title>
    <url>/2022/11/10/what-is-how-to-use-Docker/</url>
    <content><![CDATA[<h2 id="what-is-Docker"><a href="#what-is-Docker" class="headerlink" title="what is Docker"></a>what is Docker</h2><p>Docker 是一个用来开发、发布和运行应用的开放平台。<br>docker 工具目的是让开发者更简单的应用容器来创建、部署和运行应用。</p>
<h2 id="why-Docker"><a href="#why-Docker" class="headerlink" title="why Docker"></a>why Docker</h2><p>1.Docker 可以让基础架构和应用程序分离，这样可以快速交付软件。<br>2.Docker可以像管理应用软件一样管理基础架构。<br>3.利用Docker的快速交付、测试和部署方法，可以显著减少写代码和生产环境运行之间的延迟。<br>4.Docker提供工具和平台去管理容器的生命周期。</p>
<h2 id="how-to-use-Docker-amp-what-to-do"><a href="#how-to-use-Docker-amp-what-to-do" class="headerlink" title="how to use Docker &amp; what to do"></a>how to use Docker &amp; what to do</h2><p>what to do with Docker<br>1.快速一致的发布应用<br>2.响应式的部署和扩容<br>3.相同硬件上更多的工作负载</p>
<p>Docker 的工作基于容器和镜像，所以需要理解什么是容器和镜像。<br>容器是和机器上其他进程相互隔离的沙盒进程。就是一个可运行的镜像实例。<br>容器镜像就是一个包含了容器运行的文件系统、包括所有依赖、配置、脚本二进制文件等。也包含一些容器其他的配置，包括环境变量、初始运行命令和其他元数据。</p>
<h2 id="getting-start"><a href="#getting-start" class="headerlink" title="getting start"></a>getting start</h2><p>1.创建一个包含能够构建java镜像需要指令的Dockerfile<br>2.将镜像作为容器运行<br>3.建立本地开发环境，给容器连接数据库<br>4.用Docker Compose 运行这个Spring Boot应用<br>5.用Github Actions为你的应用去配置CI&#x2F;CD管道<br>6.把应用部署到云上</p>
]]></content>
      <tags>
        <tag>技术研究</tag>
      </tags>
  </entry>
  <entry>
    <title>学习agile</title>
    <url>/2022/11/09/%E5%AD%A6%E4%B9%A0agile/</url>
    <content><![CDATA[<h2 id="什么是agile"><a href="#什么是agile" class="headerlink" title="什么是agile"></a>什么是agile</h2><p>敏捷是一种迭代式的项目管理和软件开发方法，可以更快为用户提供价值。<br>敏捷团队更小的、易消耗，增量交付工作。<br>持续性的评估需求、计划和结果，因此可以容易更快响应变化。</p>
<h2 id="如何做适应agile的开发者"><a href="#如何做适应agile的开发者" class="headerlink" title="如何做适应agile的开发者"></a>如何做适应agile的开发者</h2><p>（三件事情—分支、持续集成、自动测试使得保证代码质量的情况下更有生产力）<br>branching strategy<br>分支策略可能因为团队而改变<br>三种策略： release branching 、 feature branching 、 task branching（issue branching）</p>
<p>Testing</p>
<p>CI（agile和devops的最佳实践—持续的build，和自动化测试）<br>主要包含两件事情：确保代码可编译；测试确保代码达到设计的目标<br>持续集成就是持续的向主分支集成改变的代码，同时尽可能频繁和尽早测试改变的代码。<br>CI的好处： 更快的得到代码改变的反馈。</p>
<p>CI中的测试：Unit test、API test、 Functional tests</p>
]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>学习scrum</title>
    <url>/2022/11/09/%E5%AD%A6%E4%B9%A0scrum/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>为什么我想做软件开发</title>
    <url>/2022/11/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E6%83%B3%E5%81%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="软件开发的特点"><a href="#软件开发的特点" class="headerlink" title="软件开发的特点"></a>软件开发的特点</h2><p>软件开发是比较要求逻辑性，需要逻辑清晰才能设计出运行良好的程序。<br>开发的过程需要抽象思维，描述过程、总结规律。将事物特性抽象出来，表达出关系，最终可以得到一种自动化的流程或者减少重复的动作。</p>
<h2 id="我的爱好与特长"><a href="#我的爱好与特长" class="headerlink" title="我的爱好与特长"></a>我的爱好与特长</h2><p>我认为我比较擅长逻辑思考，推理分析。<br>我学习到一些系统设计，算法设计，数据库设计，最终会得到一个系统，这个过程让我很有成就感。</p>
<h2 id="我做了什么"><a href="#我做了什么" class="headerlink" title="我做了什么"></a>我做了什么</h2><p>大学期间期末考试中得出结论，可以通过一定的方法复习，可以轻松的考高分。<br>我喜欢软件设计，所以我尝试做了一些工具性的项目，让我方便去做其他事情，比如算法设计平台，todolist。</p>
]]></content>
      <tags>
        <tag>我</tag>
      </tags>
  </entry>
  <entry>
    <title>未来</title>
    <url>/2022/11/10/%E6%9C%AA%E6%9D%A5/</url>
    <content><![CDATA[<h2 id="未来的工作"><a href="#未来的工作" class="headerlink" title="未来的工作"></a>未来的工作</h2><p>做自己喜欢的工作，WLB<br>希望可以对软件开发有所贡献。  开源软件。<br>坚持做一个content creater。</p>
<h2 id="未来的生活"><a href="#未来的生活" class="headerlink" title="未来的生活"></a>未来的生活</h2><p>坚持健身、阅读、打理好自己的形象<br>坚持记录生活。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>在写这篇文章的时候，我突然感觉，想要未来的样子，也许就是现在没有的样子。<br>规划未来，就是在给现在的自己指导要注重什么，要做什么。</p>
]]></content>
      <tags>
        <tag>我</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言到Spring框架</title>
    <url>/2022/11/11/%E4%B8%AA%E4%BA%BA%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="为什么总结"><a href="#为什么总结" class="headerlink" title="为什么总结"></a>为什么总结</h2><p>学习很多技术，总结为了<br>第一方面，加深记忆。<br>第二方面，加深理解。<br>第三方面，提炼出自己的理解，为我所用。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Java语言有这么一些概念跟面向对象有关系：<br>面向对象中的六个概念：class类、对象、抽象、继承、封装、多态<br>1、对象：<br>每一个现实世界的实体都是一个对象。 一个对象有行为和属性。 一个汽车可以移动 ，可以用价格，排量，颜色等属性。</p>
<p>2、类：<br>所有相关的对象的集合就是一个类。<br>类是所有相关对象的集合，出租车、公交车、救护车都属于汽车类。</p>
<p>3、继承：<br>一个类可以从父类中继承一些特性就好像我们从父母那里也继承了一些特性。<br> 就像手机，可以有子类 移动电话和固定电话  但是这俩都继承了打电话的特性。</p>
<p>4、封装<br>就是将数据包装到一个单元中，并且保护它<br>将想胶囊一样，将药物颗粒封装起来，与外部环境隔离。<br>银行将存储保存在保险柜里，用密码保护起来。</p>
<p>5、抽象<br>将复杂度隐藏起来，暴露简单相关的内容。<br>汽车将引擎、很多机械复杂性隐藏卡里， 用户可以用到刹车制动器、加速器、变速箱。</p>
<p>6.多态<br>多种形式。同样的名字但是有不同的形式。行为名称是一样的，不同对象的行为表现出不一样。<br>就好像下棋，棋子的行为是移动， 但是有的可以沿着对角线移动，有的只能水平和垂直移动。</p>
<h2 id="设计模式与其在框架中的应用"><a href="#设计模式与其在框架中的应用" class="headerlink" title="设计模式与其在框架中的应用"></a>设计模式与其在框架中的应用</h2><p>1.工厂模式<br>Spring IOC中用到了工厂模式去创建bean的对象实例</p>
<p>2.单例模式<br>Spring中Bean的默认为singleton单例模式。</p>
<p>3.代理模式<br>AOP模块中AopProxy, 用了JDK动态代理和CGLIB的字节码生成技术。</p>
<h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p>IOC（ioc是设计思想、依赖注入是具体实现）<br>原理以及用到的设计模式，应用场景<br>IOC带来的好处是什么，将对象的控制权和生命周期交给IOC容器，那么这个容器的过程，以及这个对象的生命周期是什么样的<br>IOC的目的是解耦， 项目开发中具体用到IOC是什么场景</p>
<p>AOP<br>原理以及用到的设计模式，应用场景<br>通过切面技术对业务主体增加额外的通知（advice），从而对声明的切点（pointcut）的代码块进行统一管理和装饰。<br>在某些方法的前后进行一些通用的操作，这些操作本身不会影响程序本身的运行。</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>自动配置<br>启动过程原理<br>常用注解</p>
<h2 id="Spring-Boot-与Spring-Cloud"><a href="#Spring-Boot-与Spring-Cloud" class="headerlink" title="Spring Boot 与Spring Cloud"></a>Spring Boot 与Spring Cloud</h2><p>springboot 专注于快速开发单个微服务个体；SpringCloud 关注全局的服务治理框架。 将springboot开发的一些单体微服务整合并管理。 提供配置管理、服务发现、断路器、路由、全局锁、分布式会话等集成服务。</p>
]]></content>
      <tags>
        <tag>个人技能</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提升口语交际能力</title>
    <url>/2022/11/11/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%8F%A3%E8%AF%AD%E4%BA%A4%E9%99%85%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>个人技能</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2022/11/12/MongoDB/</url>
    <content><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>面向文档的NoSQL数据库，用于大量数据存储。<br>mongdo的文档结构很符合开发人员编程语言中构造的类和对象。</p>
<h2 id="为什么用"><a href="#为什么用" class="headerlink" title="为什么用"></a>为什么用</h2><ul>
<li>面向文档： 数据存储在文档中，使得Mongo非常灵活，可以适应实际的业务环境和需求。</li>
<li>负载均衡：使用分片的概念，通过多个mongo实例之间拆分数据来水平扩展。可以在多台服务器上运行，以平衡负载或复制数据，以便在硬件出现故障时保持系统正常运行。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>文档的分组，集合等效于RDBMS中创建的表。集合存在于单个数据库中。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>集合的记录。文档包含字段名称和值。<br>mongo将数据存储为一个文档，类似于JSON对象<br>数据由键值对组成，类似于Java的Map</p>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>字段包含名称和值。一个文档拥有零个或者多个字段。 字段类似于关系数据库中的列。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>mongoDB 为了web提供可扩展的高性能数据存储解决方案</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/11/12/MySQL/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>字段类型<ul>
<li>整型<br>  TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</li>
<li>浮点数<br>  FLOAT、DOUBLE、DECIMAL</li>
<li>字符串<br>  CHAR、VARCHAR</li>
<li>时间和日期<ul>
<li><ol>
<li>DATETIME （1001-9999年）</li>
</ol>
</li>
<li><ol start="2">
<li>TIMESTAMP（从1970.1.1开始的秒数）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用语法规则与编程技巧"><a href="#常用语法规则与编程技巧" class="headerlink" title="常用语法规则与编程技巧"></a>常用语法规则与编程技巧</h2><p>多表联查方法：内连接、左外连接、右外连接、全外连接、笛卡儿积</p>
<h2 id="SQL优化常用方法及场景"><a href="#SQL优化常用方法及场景" class="headerlink" title="SQL优化常用方法及场景"></a>SQL优化常用方法及场景</h2><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul>
<li><p>InnoDB<br>MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
</li>
<li><p>MyISAM<br>不支持事务</p>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="索引-B-数"><a href="#索引-B-数" class="headerlink" title="索引 B+数"></a>索引 B+数</h2><ol>
<li>数据结构特点</li>
<li>与红黑树的区别</li>
</ol>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><ul>
<li>策略</li>
<li>管理</li>
</ul>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行项目</title>
    <url>/2022/11/12/%E6%97%85%E8%A1%8C%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="为什么做这个"><a href="#为什么做这个" class="headerlink" title="为什么做这个"></a>为什么做这个</h2><p>想把旅行的一些经历和想法记录下来。</p>
<h2 id="项目架构与模块"><a href="#项目架构与模块" class="headerlink" title="项目架构与模块"></a>项目架构与模块</h2><ul>
<li><p>项目技术栈<br>基于SpringBoot的单体项目，spring security、JPA、MySQL、JWT<br>业务类、登录与注册、认证与授权、数据存储</p>
</li>
<li><p>项目流程<br>注册流程<br>登录流程</p>
</li>
</ul>
<p>授权与认证流程</p>
<p>数据操作流程</p>
<h2 id="项目遇到的问题"><a href="#项目遇到的问题" class="headerlink" title="项目遇到的问题"></a>项目遇到的问题</h2><h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2>]]></content>
      <tags>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务项目</title>
    <url>/2022/11/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="为什么做这个"><a href="#为什么做这个" class="headerlink" title="为什么做这个"></a>为什么做这个</h2><p>为了尝试与学习微服务技术栈（感兴趣所以就尝试去做了）</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>项目技术栈<br>SpringBoot、SpringCloud gateway、注册中心Eureka、Prometheus系统监控、Docker容器化</p>
<p>网关的登录与路由、服务注册与发现、应用容器化、系统监控</p>
<p>流程<br>网关路由流程<br>服务注册中心流程<br>容器化过程<br>系统监控流程</p>
<h2 id="项目遇到的问题"><a href="#项目遇到的问题" class="headerlink" title="项目遇到的问题"></a>项目遇到的问题</h2><h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2>]]></content>
      <tags>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题</title>
    <url>/2022/11/13/Java/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>访问权限</li>
<li>接口与抽象类</li>
<li>super</li>
<li>重写与重载</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类 和抽象方法 需要用abstract 关键字声明。 抽象类一般包含抽象方法。<br>抽象类和一般类的区别在于抽象类不能被实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">AbstractClassExample</span> <span class="variable">ac2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractExtendClassExample</span>();</span><br><span class="line">ac2.func1();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用抽象类：</p>
<ol>
<li>需要多个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，并不都是public。</li>
<li>需要继承非静态和非常量字段。</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是完全抽象的类，在 Java8之前， 就是不能有任何的方法实现<br>在Java 8开始，接口可以拥有默认的方法实现，因为不支持默认方法的接口维护成本太高了。</p>
<p>接口的成员（字段+方法）都是默认public，并且不允许定义为Private 或 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">InterfaceExample</span> <span class="variable">ie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceImplementExample</span>();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用接口</p>
<ol>
<li>需要让不相关的类都实现一个方法，例如不相关的类都实现Comparable接口中的compareTo()；</li>
<li>想要确定特定数据类型的行为，但是不关心谁实现这个行为。 </li>
<li>需要使用多重继承。</li>
</ol>
<h2 id="抽象类与接口区别"><a href="#抽象类与接口区别" class="headerlink" title="抽象类与接口区别"></a>抽象类与接口区别</h2><p>使用上来说，一个类可以实现多个接口，但是不能继承多个抽象类。<br>接口的字段 只能是static 和final类型，抽象类没有限制。<br>接口成员只能是public，抽象类成员可以有多种访问权限。</p>
<p>选择：<br>很多时候，接口优于抽象类，因为接口没有抽象类严格的类层级结构要求，可以灵活为一个类添加行为。 并且从Java8开始，接口也可以有默认的方法实现，使得修改接口的成本很低。</p>
<h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><p>重写（override）<br>发生在继承关系中，子类实现父类方法声明完全相同的方法。<br>为了满足里氏替换原则有两个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法。</li>
<li>子类方法的返回类型必须是父类返回类型或者其子类型。</li>
</ul>
<p>使用@Override注解，可以让编译器帮忙检查是否满足以上两个条件。</p>
<p>重载（overload）<br>存在于同一个类中， 一个方法与已经存在的方法名称上相同，但是参数类型、个数和顺序至少有一个不同。<br>但是 返回值不同，其他都相同不算重载。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见的异常</title>
    <url>/2022/11/13/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="常见异常类型"><a href="#常见异常类型" class="headerlink" title="常见异常类型"></a>常见异常类型</h2><ul>
<li>NullPointerException 空指针异常</li>
<li>ArrayIndexOutOfBoundsException 索引越界异常</li>
<li>InputFormatException输入类型不匹配异常</li>
<li>SQLException SQL异常</li>
<li>IllegalArgumentException 非法参数异常</li>
<li>NumberFormatException 类型转换异常</li>
</ul>
<h2 id="异常解决方法"><a href="#异常解决方法" class="headerlink" title="异常解决方法"></a>异常解决方法</h2><p>Java内建了通用的异常，以Throwable为顶层父类。<br>Throwable派生出Error和Exception类。</p>
<p>Error：Error类以及子类的实例，代表JVM本身的错误，不能被程序员通过代码处理。<br>Exception：Exception以及子类，代表程序运行时发送的各种不期望发生的时间。可以被java异常处理机制使用，是异常处理的核心。</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><ol>
<li><p>try catch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)&#123;</span><br><span class="line"><span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw<br>throw 关键字作用是抛出一个异常，抛出时候是抛出一个异常类的实例化对象，在异常处理中，try语句捕获的就是一个异常对象，那么异常对象也可以自己抛出。</p>
</li>
<li><p>throws<br>定义一个方法的时候可以用throws关键字声明。使用throws关键字声明的方法表示此方法不处理异常，而交给方法调用着进行处理。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据类型</title>
    <url>/2022/11/13/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="大分类"><a href="#大分类" class="headerlink" title="大分类"></a>大分类</h2><p>基本数据类型 8个， 引用类型 3个</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>byte（8）、short（16）、int（32）、long（64） 属于数值型中的整数型</li>
<li>float（32）、double（64）属于浮点类型</li>
<li>char（16） 属于字符型</li>
<li>boolean（1） 属于布尔型</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>类、接口、数组</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>java的8个基本数据类型，分别对应8个包装类，包装类型和基本类型之间的赋值通过自动装箱与拆箱完成。</p>
<ul>
<li>byte – Byte</li>
<li>boolean – Boolean</li>
<li>short – Short</li>
<li>char – Character</li>
<li>int – Integer</li>
<li>long – Long</li>
<li>float – Float</li>
<li>double – Double<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为什么要包装类"><a href="#为什么要包装类" class="headerlink" title="为什么要包装类"></a>为什么要包装类</h2><ul>
<li>基本数据类型简单，但是不支持泛型和集合。</li>
<li>不符合面向对象思维。</li>
<li>包装类提供很多方法，方便使用。如：Integer类toHexString（int i）、parseInt（String s）等。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux与shell脚本</title>
    <url>/2022/11/12/Linux%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计网应用token、cookie和session</title>
    <url>/2022/11/12/%E8%AE%A1%E7%BD%91%E5%BA%94%E7%94%A8token%E3%80%81cookie%E5%92%8Csession/</url>
    <content><![CDATA[<h2 id="session-和cookie-和token分别是什么"><a href="#session-和cookie-和token分别是什么" class="headerlink" title="session 和cookie 和token分别是什么"></a>session 和cookie 和token分别是什么</h2><p>session 是基于Cookie实现的一种记录服务端和客户端会话状态的机制。<br>Session存储在服务端。 SessionID 会被存储在客户端的Cookie中。</p>
<h2 id="session-和cookie-和token分别为什么"><a href="#session-和cookie-和token分别为什么" class="headerlink" title="session 和cookie 和token分别为什么"></a>session 和cookie 和token分别为什么</h2><p>cookie<br>在HTTP&#x2F;1.1 引入cookie来保存状态信息，使得http协议尽可能的简单。<br>随着现在浏览器的存储方式，cookie逐渐被淘汰。</p>
<h2 id="session-和cookie-和token应用场景"><a href="#session-和cookie-和token应用场景" class="headerlink" title="session 和cookie 和token应用场景"></a>session 和cookie 和token应用场景</h2><p>cookie</p>
<ol>
<li>session management 会话管理<br>登录、购物车、游戏分数等 任何服务器来存储的数据 </li>
<li>personalization 个性化<br>用户偏好、主题 和其他设置</li>
<li>tracking 跟踪<br>记录和分析用户行为</li>
</ol>
<h2 id="session-和cookie-和token区别"><a href="#session-和cookie-和token区别" class="headerlink" title="session 和cookie 和token区别"></a>session 和cookie 和token区别</h2>]]></content>
      <tags>
        <tag>项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象引用</title>
    <url>/2022/11/15/Java%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是引用数据类型"><a href="#什么是引用数据类型" class="headerlink" title="什么是引用数据类型"></a>什么是引用数据类型</h2><p>引用数据类型是 在创建的时候，会先在堆内存中分配一块空间，存储对象的具体信息，然后在栈中存储该对象的地址信息。</p>
<h2 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h2><ul>
<li>强引用<br>  垃圾回收器不会回收被引用对象，哪怕内存不足，JVM会直接抛出OutOfMemoryError，除非赋值为null；</li>
<li>软引用<br>  描述一些非必需但仍有用的对象。在内存足够时，软引用不会回收，只有在内存不足时，系统回收。</li>
<li>弱引用<br>  无论内存是否足够，只要JVM进行垃圾回收，那些被弱引用的对象都会被回收。</li>
<li>虚引用<br>  主要用来跟踪对象被垃圾回收器回收的活动。<br>  无法通过虚引用来获取对象。虚引用必须和（ReferenceQueue）引用队列一起使用，NIO的堆外内存就是靠其管理。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用集合与实现</title>
    <url>/2022/11/15/Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>1.8版本的变化</li>
</ul>
<ol>
<li>加入红黑树</li>
<li>插入数据方式变为尾插法、</li>
<li>hash值计算方式变为2次扰动处理（1次位运算+1次异或）</li>
<li>扩容策略变化，插入后再扩容</li>
</ol>
<ul>
<li>线程不安全：<br>1.7中，扩容采用头插法，可能出现循环链表，为了修复改为尾插法。<br>HashMap任意版本中，如果在插入数据时多个线程命中了同一个槽，可能数据覆盖的情况，导致线程不安全。</li>
</ul>
<p>线程不安全解决方案</p>
<ol>
<li>给HashMap直接加锁</li>
<li>使用Hashtable，比方法1效率高，原理是在方法上加Synchronized锁</li>
<li>使用concurrentHashMap，本质是减小了锁的粒度，减少线程竞争，更高效。</li>
</ol>
<ul>
<li>与concurrentHashMap的区别</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>版本区别：</p>
<ol>
<li>1.7 锁粒度 基于segment  1.8基于entry节点</li>
<li>1.7锁用reentrantLock   1.8用synchronized</li>
<li>底层结构1.7 segment  + HashEntry + Unsafe  ； 1.8 Synchronized + CAS + Node + Unsafe</li>
</ol>
<h2 id="ArrayList-amp-LinkedList（双向链表）"><a href="#ArrayList-amp-LinkedList（双向链表）" class="headerlink" title="ArrayList &amp; LinkedList（双向链表）"></a>ArrayList &amp; LinkedList（双向链表）</h2><ol>
<li>对于随机访问，ArrayList 优先，因为基于数组实现，存储空间连续，支持随机访问</li>
<li>对于新增和删除数据，LinkedList优先，因为ArrayList要移动数据。</li>
<li>同样数据量LinkedList所占空间更小，ArrayList需要预留空间便于后续数据增加，而LinkedList只需要增加一个节点。</li>
</ol>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>set继承于Collection接口，不允许出现重复元素，并且无序。<br>HashSet基于HashMap实现，底层用HashMap保存元素。<br>元素哈希值通过元素hashcode方法来获得，首先判断hashcode，之后判断equals，如果都相同视为同一个元素。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象的生命周期</title>
    <url>/2022/11/15/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java版本特性</title>
    <url>/2022/11/15/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p>函数编程（lambda表达式）</p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>将提供长期支持服务，将作为Java默认支持版本。指导2023年9月<br>从8 到 11</p>
<ol>
<li>语言新特性</li>
<li>新工具和库更新</li>
<li>JVM优化</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中Bean的生命周期</title>
    <url>/2022/11/15/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="Bean初始化的大致4个阶段"><a href="#Bean初始化的大致4个阶段" class="headerlink" title="Bean初始化的大致4个阶段"></a>Bean初始化的大致4个阶段</h2><ol>
<li>实例化（instantiation）</li>
<li>属性赋值（populate）</li>
<li>初始化（initialization）</li>
<li>销毁（destruction）</li>
</ol>
<h2 id="涉及到的扩展点的作用"><a href="#涉及到的扩展点的作用" class="headerlink" title="涉及到的扩展点的作用"></a>涉及到的扩展点的作用</h2><ol>
<li>Aware接口<br>通过让Bean实现Aware接口，在bean中获取响应的Spring容器资源。</li>
<li>BeanPostProcessor<br>是Spring修改Bean提供的强大扩展点，可作用于容器中所有Bean。</li>
</ol>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理与反射</title>
    <url>/2022/11/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>什么是反射？<br>哪里用到了反射？怎么用的？<br>反射原理？</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何准备一场视频面试</title>
    <url>/2022/11/15/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E4%B8%80%E5%9C%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="搜集相关问题及解决方案"><a href="#搜集相关问题及解决方案" class="headerlink" title="搜集相关问题及解决方案"></a>搜集相关问题及解决方案</h2><h2 id="组织回答问题的语言"><a href="#组织回答问题的语言" class="headerlink" title="组织回答问题的语言"></a>组织回答问题的语言</h2><h2 id="模拟面试"><a href="#模拟面试" class="headerlink" title="模拟面试"></a>模拟面试</h2><p>录像，对回答问题的形式和内容进行修正和补充。</p>
<h2 id="修正与补充"><a href="#修正与补充" class="headerlink" title="修正与补充"></a>修正与补充</h2><h2 id="重复以上步骤"><a href="#重复以上步骤" class="headerlink" title="重复以上步骤"></a>重复以上步骤</h2>]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>认证与授权</title>
    <url>/2022/11/15/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://javaguide.cn/system-design/security/basis-of-authority-certification.html#%E8%AE%A4%E8%AF%81-authentication-%E5%92%8C%E6%8E%88%E6%9D%83-authorization-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">https://javaguide.cn/system-design/security/basis-of-authority-certification.html#%E8%AE%A4%E8%AF%81-authentication-%E5%92%8C%E6%8E%88%E6%9D%83-authorization-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88</a></p>
]]></content>
      <tags>
        <tag>软件开发理解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/11/16/JVM/</url>
    <content><![CDATA[<h2 id="JVM-、JRE和JDK"><a href="#JVM-、JRE和JDK" class="headerlink" title="JVM 、JRE和JDK"></a>JVM 、JRE和JDK</h2><ul>
<li>JVM<br>  java运行在虚拟机上，在不同的平台上有不同的虚拟机，从而实现跨平台。</li>
<li>JRE<br>  java运行环境，包含JVM和核心类库，如lang包：系统类、包装类型、基本数学函数、字符串处理、线程、异常处理类等。 如果只要运行java，安装JRE就行。</li>
<li>JDK<br>  包含JRE和一些开发工具，如JAVA.exe、JAVAc.exe、Jar.exe java运行、编译和打包工具等。</li>
</ul>
<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><pre><code>作用 ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的解释器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。
</code></pre>
<h2 id="内存模型（深入理解）"><a href="#内存模型（深入理解）" class="headerlink" title="内存模型（深入理解）"></a>内存模型（深入理解）</h2><p>线程私有：栈、本地方法栈、程序技术器<br>线程共享：堆、方法区</p>
<h2 id="类加载机制（了解）"><a href="#类加载机制（了解）" class="headerlink" title="类加载机制（了解）"></a>类加载机制（了解）</h2><h2 id="GC（了解）"><a href="#GC（了解）" class="headerlink" title="GC（了解）"></a>GC（了解）</h2><h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2>]]></content>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>how to add a feature?</title>
    <url>/2022/11/19/how-to-add-a-feature/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>how to build a feature?</title>
    <url>/2022/11/19/how-to-build-a-feature/</url>
    <content><![CDATA[<h2 id="Documentations"><a href="#Documentations" class="headerlink" title="Documentations"></a>Documentations</h2><ol>
<li>understand the project structure and parrterns.</li>
<li>code standards and best practices.</li>
</ol>
<h2 id="Run-the-project"><a href="#Run-the-project" class="headerlink" title="Run the project"></a>Run the project</h2><ol>
<li>try to use the project, try the existing functions.</li>
</ol>
<h2 id="Understand-the-features"><a href="#Understand-the-features" class="headerlink" title="Understand the features"></a>Understand the features</h2><ol>
<li>learn about the feature’s requirements.</li>
</ol>
<h2 id="Understand-the-structure-of-code"><a href="#Understand-the-structure-of-code" class="headerlink" title="Understand the structure of code"></a>Understand the structure of code</h2><ol>
<li>to figure out where(which package, which layer) your feature’s code belong to.</li>
</ol>
]]></content>
      <tags>
        <tag>软件开发理解</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 与 分布式文件系统</title>
    <url>/2022/11/24/hexo-%E4%B8%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="分布式特点："><a href="#分布式特点：" class="headerlink" title="分布式特点："></a>分布式特点：</h2><p>并行处理：多台机器同时处理同一功能<br>节点可以访问系统中其他节点并与之通信。</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务是分布式系统，将应用分解为单独的组件或“服务”。系统拥有服务的多个冗余副本，服务不会出现集中故障点。<br>更具组合型，可以重复利用小型服务节点提供的功能。微服务更加稳健，可实现更灵活的的垂直和水平扩展。</p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>hashcode 和 equals</title>
    <url>/2022/11/20/hashcode-%E5%92%8C-equals/</url>
    <content><![CDATA[<h2 id="为什么要重写方法"><a href="#为什么要重写方法" class="headerlink" title="为什么要重写方法"></a>为什么要重写方法</h2><p>默认的hashcode 和 equals方法都是继承自Object类中。<br>equals方法去判断两个对象引用的地址是否相同。</p>
<p>在一般情况中，比如创建了两个用户对象，参数相同的情况下，equals方法对比，结果为false。因为是new出来的两个对象，引用指向的地址一定不同，所以equals结果为false。</p>
<p>hashcode也不同。 放入map或者set中时，两个相同的对象，却会重复出现两次。违背了map和set的特性。本来想要像个相同的对象判断成了不同的对象，为了达到目的，让我们认为两个相同的对象判断也是同一个对象，所以需要重写原来的hashcode和equals方法。</p>
<p>原因：<br>set根据hashcode 是否相同，在判断equals是否相同来判断是否为同一个对象。<br>map根据key值的hashcode值分配和获取对象保存数组下标，然后根据equals判断是否唯一。</p>
<h2 id="什么时候重写"><a href="#什么时候重写" class="headerlink" title="什么时候重写"></a>什么时候重写</h2><h2 id="如何重写"><a href="#如何重写" class="headerlink" title="如何重写"></a>如何重写</h2><p>只重写equals方法也不行，因为在集合中判断两个对象是否相同时，会用到hashcode方法，所以重写equals同时也要重写hashcode方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2022/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h2><p>事务是由一系列数据库操作组成的一个完整的逻辑过程。如银行转账。一个完整的逻辑过程，不可拆分，这个过程叫事务。 具有ACID特性。</p>
<ul>
<li>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成。</li>
<li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</li>
<li>隔离性：隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>
<li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p>事务隔离的级别：（）</p>
<ol>
<li>读未提交（Read uncommitted）：脏读、不可重复读、幻读都可能出现</li>
<li>读提交（read committed）： 可以避免脏读。</li>
<li>可重复读（repeatable read）：避免脏读、不可重复读，但是会幻读。</li>
<li>串行化（Serializable）：性能很低、事务顺序执行、避免脏读、不可重复读、和幻读问题。<br>隔离级别从低到高，性能逐渐减低、但是事务数据一致性增高。</li>
</ol>
<p>脏读、不可重复读、幻读</p>
<ul>
<li>脏读：事务2查看了事务1未提交的更新事务，结果事务1回滚了，就是脏读。</li>
<li>幻读:  事务2在事务1的两次查询之间插入了新的值，导致两次数据（条数、量）不一致。</li>
<li>不可重复读：事务2在事务1的两次查询之间更新了新的值，导致查询结果不一致。</li>
</ul>
<h2 id="手写常用语句"><a href="#手写常用语句" class="headerlink" title="手写常用语句"></a>手写常用语句</h2><p>条件查询<br>关联查询<br>排序查询<br>分组查询<br>逻辑关键字<br>常用函数（count、sum、order by）</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>整数型<br>浮点型<br>字符串<br>二进制<br>时间</p>
<h2 id="存储引擎（特点）"><a href="#存储引擎（特点）" class="headerlink" title="存储引擎（特点）"></a>存储引擎（特点）</h2><p>MyIASM      支持全文检索，查询效率高；  不支持事务， 使用表级锁<br>InnoDB        支持ACID事务，支持外键、行级锁， 使用行级锁，提高了并发效率</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li>表锁<br>粒度大，锁冲突几率大，</li>
<li>行级锁<br>锁的粒度小，并发冲突几率低，并发效率高</li>
<li>共享锁</li>
<li>排他锁</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>大幅增加数据库的查询性能，需要额外的空间来存储索引，<br>适合应用到读多写少的场景。</p>
<ul>
<li>类型：</li>
</ul>
<ol>
<li><p>唯一索引</p>
</li>
<li><p>主键索引 不允许空值</p>
</li>
<li><p>普通索引</p>
</li>
<li><p>联合索引 注意最左原则</p>
</li>
<li><p>全文索引 （MyISAM）  5.6版本之后 InnoDB也实现了全文索引</p>
</li>
</ol>
<ul>
<li>索引实现</li>
</ul>
<ol>
<li>B-Tree</li>
<li>R-Tree</li>
<li>Hash  散列表 效率高，但不支持范围查找，实际使用较少。</li>
<li>FullText 记录关键字与对应文档的倒排索引</li>
</ol>
<h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><p>避免重复编写语句</p>
<ul>
<li><p>存储过程</p>
</li>
<li><p>函数</p>
</li>
</ul>
<h2 id="新特性（8-0）"><a href="#新特性（8-0）" class="headerlink" title="新特性（8.0）"></a>新特性（8.0）</h2><p>隐藏索引、通用表表达式、窗口函数（）</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>表结构与索引</li>
<li>SQL语句优化</li>
<li>参数优化</li>
<li>硬件及系统配置<br>优化成本逐渐升高，但是优化效果 逐渐降低</li>
</ol>
<ul>
<li>表结构与索引优化</li>
</ul>
<ol>
<li>分库分表，读写分离</li>
<li>为字段选择合适的数据类型， 尽可能小</li>
<li>字段多的表分解成多个表</li>
<li>为经常使用查询的创建索引</li>
<li>列字段尽量设置not null</li>
</ol>
<ul>
<li>SQL语句优化</li>
</ul>
<ol>
<li>找到最需要优化的查询语句：使用频率最高、优化后提高最明显的语句。（分析慢查询日志）</li>
<li>使用分析工具：explain、profile</li>
<li>避免使用Select * ，指定需要获取的字段（避免查询列字段的元信息）</li>
<li>尽量使用prepared statements （性能更好、防止SQL注入）</li>
<li>使用索引扫描来排序</li>
</ol>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2022/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>英语学习心得</title>
    <url>/2022/11/24/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>英语学习 和其他很多学习一样， 持之以恒，每天学一点，当天不会感觉到什么，当坚持做了很久之后，就会感觉到自己能听懂了， 自己能读好了， 自己能说出来了， 自己能运用。</p>
]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="4-x2F-7层模型"><a href="#4-x2F-7层模型" class="headerlink" title="4&#x2F;7层模型"></a>4&#x2F;7层模型</h2><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><ul>
<li>基于链接 （点对点）</li>
<li>双工通信</li>
<li>可靠传输（基于字节流，将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制，保证接收数据的有序性和完整性。）</li>
<li>流量控制，滑动窗口控制数据的发送速率，滑动窗口的本质是数据的动态缓冲区，接收端根据自己的接收能力在Header中动态调整窗口大小，通过ACK应答包通知给发送端，发送端根据窗口的大小调整发送的速度。</li>
<li>拥塞控制： （四个算法：慢启动、拥塞避免、拥塞发生、快速恢复）<br>报文状态<br>三握四挥<br>keepalive<br>滑动窗口 进行流量控制</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>协议：Method、Header、Cookies<br>状态码<br>HTTPS 交互流程<br>HTTP 2.0  多路复用、Stream、流量控制、服务端推送</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2>]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2022/11/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分布式系统</title>
    <url>/2022/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Distributed System Engineering lecture 1</title>
    <url>/2022/11/30/Distributed-System-Engineering-lecture-1/</url>
    <content><![CDATA[<h2 id="what-is-this-lecture-all-about？"><a href="#what-is-this-lecture-all-about？" class="headerlink" title="what is this lecture all  about？"></a>what is this lecture all  about？</h2><p>big view on the distrubuted system,<br>consistency-performance-fault tolerance</p>
<p>a study case on MapReduce about how it works, </p>
]]></content>
      <tags>
        <tag>distributed system</tag>
      </tags>
  </entry>
  <entry>
    <title>ToDoList</title>
    <url>/2022/12/31/ToDoList/</url>
    <content><![CDATA[<h2 id="为什么做"><a href="#为什么做" class="headerlink" title="为什么做"></a>为什么做</h2><p>用来记录和规划每天要做什么事情，更高效的完成想要去做的事情。</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>前后端分离- 后端：SSM + MySQL</p>
<h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><p>后端模块设计：</p>
<ol>
<li>用户注册与登录</li>
<li>话题模块</li>
<li>任务模块</li>
</ol>
<h2 id="项目中遇到的问题"><a href="#项目中遇到的问题" class="headerlink" title="项目中遇到的问题"></a>项目中遇到的问题</h2><p>Description:</p>
<p>Parameter 1 of constructor in com.example.todolist.service.AuthService required a bean of type ‘org.springframework.security.authentication.AuthenticationManager’ that could not be found.</p>
<p>Action:</p>
<p>Consider defining a bean of type ‘org.springframework.security.authentication.AuthenticationManager’ in your configuration.</p>
<p>找不到对应的Bean，但是这个Bean是在Security包中的。</p>
<h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2><h3 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h3><h3 id="业务亮点"><a href="#业务亮点" class="headerlink" title="业务亮点"></a>业务亮点</h3><p>业务亮点就是 每个任务会有一个预估的完成时间，用户可以去执行任务的时候开启倒计时功能，倒计时结束时，表示用户完成了任务；当用户完成一个话题的相关所有任务的时候，这个话题会进入已完成的话题列表，很有成就感。</p>
]]></content>
      <tags>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS 原理与应用</title>
    <url>/2022/12/07/CAS-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="CAS原理（对比-交换）"><a href="#CAS原理（对比-交换）" class="headerlink" title="CAS原理（对比 交换）"></a>CAS原理（对比 交换）</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2>]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>用户注册与登录</title>
    <url>/2022/12/31/%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="用户登录实现方法"><a href="#用户登录实现方法" class="headerlink" title="用户登录实现方法"></a>用户登录实现方法</h2><p>后端的输入与输出<br>输入：用户名和密码、手机号和密码<br>后端通过查询用户表对照用户输入的信息是否正确来认证用户身份。<br>如果身份验证通过，后端给用户返回一个Token，ID，用户持有这个ID或者Token来进行接下来的系统访问操作。</p>
]]></content>
      <tags>
        <tag>项目开发</tag>
      </tags>
  </entry>
</search>
