[{"title":"Hello World","url":"/2022/11/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"我如何应对我正在经历的困难","url":"/2022/11/09/%E6%88%91%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%88%91%E6%AD%A3%E5%9C%A8%E7%BB%8F%E5%8E%86%E7%9A%84%E5%9B%B0%E9%9A%BE/","content":"Hello World！我目前的状况目前我在杭州，没有固定的居住地，每天需要寻找一个安静的能提供我进行面试准备的环境。 一方面我可以改简历，一方面我可以准备项目。我解决了居住地的问题，我打算这几天都住在这个安静的、让我舒服的青年旅舍。 我有时间和空间来做我想做的事情。我没有找其他的也许可以很快开始的，同时也足够让我生活在这个城市的工作。因为我觉得我具备去做我专业技能相关工作的能力。我觉得我具备很强的逻辑推理能力，思维敏捷，可以去解决很复杂的问题。我想要通过靠做软件开发的工作来生活。因为做软件开发的工作会让我觉得很兴奋，我对于这件事情很有激情。我为此做了很多准备。但是目前我没有得到什么机会。\n做这个博客的目的我觉得我现在头脑里面有很多想法，所以我打算搭建这个博客，一个我愿意经常使用的博客，而不是直接可以去发布的像CSDN。这是不一样的体验，这个平台是我自己给自己搭建起来的，我可以选择自己的主题，选择自己的编辑器。可以让我感觉自己在像一个专业的人在工作一样。\n我对公司的期待工作内容：有创造性的，有挑战的工作。公司文化：我想要公司的团队成员能够有很融洽的关系， 很强的合作意识和逻辑思维能力。包容的，多元的，团队合作的。\n这个文章需要拓展， 第一篇文章要写的内容是 我为什么要搭建这个博客。 以及我想要写那些内容。\n","tags":["思路总结"]},{"title":"对于做项目的理解","url":"/2022/11/09/%E5%AF%B9%E4%BA%8E%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%90%86%E8%A7%A3/","content":"如何开始一个项目构建一个项目， 不意味着从0开始做项目，也许可以复用代码（但是需要理解代码作用），也许可以在这个原有项目的基础上增加一些新的模块，再进行修改或删除一些旧代码同时增加一些新代码。\n做小&#x2F;新项目的价值\n在新项目中会遇到新的问题，解决新问题就是提升能力。\n参考别人的设计思路和实现方案。\n集中深入使用一个技术点，可以更深入的理解和应用一个技术。\n逐渐形成&#x2F;建立起自己的工作方式&#x2F;解决问题的体系。\n提高影响力&#x2F;经济价值。总之就是增加新技能，增强知识理解和应用能力。\n\n","tags":["软件开发理解"]},{"title":"self introduction","url":"/2022/11/09/self-introduction/","content":"职业我在干什么我在找工作，目前的意向岗位是软件开发、后端开发。\n我的技术生涯我的技术学习主要是在大学和大学毕业后自学的。我主要学习的技术栈在大学期间是后端开发，毕业之后学习了前端开发，自己做过一些全栈开发的项目，也组织过软件开发小组，一起做项目。前端：JS、React、Vue后端：Java、Spring、MyBatis、JPA、MySQL、Redis、MongoDB协同：Maven、GIT\n项目经验可以做全栈的项目，但是我更偏好做后端，因为在后端方面花了更多时间学习，看了很多书，所以后端的部分更自信。\n主要是基于SpringBoot开发的项目，比较喜欢做工具相关的项目。这样的项目目的是可以方便我学习或者自我提升的工具。\nTODO-List（规划每天要干什么）、 AlgorithmDesignCanvas（算法训练平台）\n我的学习方法和途径我的思想是通过多种途径（多种资源和多个人）学习，可以增强我对于一个概念的理解。通过更多的练习，可以让我对于一些技术有更熟练的应用能力。\n对标以上两个理念，我产生了我的方法，以及我怎么找资源。\n我通过看官方文档学习Spring（因为很细节、很全面、还有一些上手的例子）我会通过看视频学习，Coursera上课，github仓库找项目、Google看一些文档或者概念\n我的职业规划两到三年之内，我规划是广度优先扩展，希望自己对这个行业有更多的学习、认知和尝试。三年之后，深度优先，对于行业有自己的清晰的发展方向，开始深入研究，希望有所贡献。\n其他我认为很多事情是相互产生影响的。比如我在旅行的过程中，我会有很多想法在大脑浮现出来。我会对很多事情有一些更深入的思考，或者有一些新的想法。\n内容创作通常我会把自己的一些想法记录下来，不同的阶段会有不同的工具去记录。在家的时候，有时会写在日记本上。 还有很多会记录在手机的便签上。也有一些会记录在github、其他的手机笔记本上，电脑的便签上。我觉得这样记录很零散，不便于之后查找一些信息，所以我决定专注于自己这个Github博客上，进行内容创作。\n平时的一些想法 小的点子会记录在手机便签里。最后都整理在这个博客里。\n旅行我喜欢旅行，因为我在离开一个地方的时候，我会有很多想法浮现出来，我通常会在交通工具上思考，并记录一些内容。我喜欢看山水，喜欢自然风光。\n运动健身篮球，各种球类街头健身\n阅读职业相关： 《The Passionate Programmer》、《Soft Skills: The Software Developer’s Life Manual》\n","tags":["我"]},{"title":"如何学习编程","url":"/2022/11/09/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B/","content":"逻辑你的大脑就是一块肌肉，学习就好像健身，需要持续性的、不断重复的练习。 持续性很重要。\n肌肉增长原理肌肉增长需要负荷渐进的训练。 不断提升肌肉负担的重量，让肌肉撕裂，补充营养和休息，肌肉愈合后增长出更长更粗的纤维。力量增长的更大了，可以负担下一个重量的训练，不断成长。\n学习原理学习就是不断遇到新的问题和困难，通过学习来解决问题，增长能力。\n\n学习概念，定义问题起初不知道这个概念，就需要补充材料，获取核心概念，利用这个概念和原理来重新定义问题。\n\n学习工作原理，研究解决方案有了更准确的定义问题，就能研究解决方案，学习原理，分析解决方案。\n\n动手实践了解了原理，和实际掌握能力还有差距，就是实践的过程。实践的过程就是不断的应用理论，实际的环境和原理的区别就是存在很多环境变量，这个环境变量是不确定的，原理的应用也许会有偏差，实践就是让原理更深入的理解，去适应不同的环境变量，从而真正的掌握技能。\n\n\n如何学习？学习一个新的概念，是因为它好用，用它可以节省时间，可以节省体力，它可以让系统消耗更小，可以有更快的响应时间等，总之就是为了能够应用并能带来好处。\n那么学习编程的一些概念就是为了理解，并应用到自己的场景中。\n首先入手 概念，这个名词，是什么，为什么产生，为什么用。懂了概念之后，learn by doing！开始着手怎么用，如何应用到自己的场景中。\n具体流程\n基本语法： 数据类型、变量、逻辑控制语句、运算符、注释、函数。\n数组、枚举、集合。\n常用类。\n语言特性：编程模式、语言自身特性。\n代码组织、模块加载、库管理。\n容错处理：异常、日志、调试、测试。\n输入输出与文件处理。\n回调机制。\n序列化与反序列化。\n进阶特性： 并发、反射、泛型、元数据， 根据开发需求去学习。\n库和框架，构建技术生态圈，实际应用领域去学习。\n\n","tags":["编程"]},{"title":"如何掌握一个技能","url":"/2022/11/09/%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E4%B8%80%E4%B8%AA%E6%8A%80%E8%83%BD/","content":"重复掌握一个技巧之前，状态是要么完全不会，要么不完全会。不断的重复练习，目的是暴露并发现自己不会、不懂的地方，对这些地方学习，或改正，在下一次练习的时候去避免。避免之前犯过的错误，分析为什么出现这个错误，正确的是什么样子。Ever tried， ever failed.No Matter. Try again, fail again. Fail better.重复的练习的生命周期：练习-&gt;暴露问题-&gt;改善问题，避免相同错误-&gt;从而不断减少错误-&gt;从而逐渐熟练。\n应用应用是目标。 为了能够应用，而去掌握一门技能。学习游泳不是为了学会游泳，而是为了游泳。学习编程不是为了会解决两数之和的问题，不是为了写hello，world。而是用编程去计算出一个问题，设计一个网页，做一个产品。所以学会一些技能之后要去用。\n","tags":["技巧"]},{"title":"what is & how to use kubernetes","url":"/2022/11/10/what-is-how-to-use-kubernetes/","content":"what is kubernetesk8s 是一个用来自动部署，扩展和管理容器化的应用的开源系统。\n","tags":["技术研究"]},{"title":"what is & how to use Docker","url":"/2022/11/10/what-is-how-to-use-Docker/","content":"what is DockerDocker 是一个用来开发、发布和运行应用的开放平台。docker 工具目的是让开发者更简单的应用容器来创建、部署和运行应用。\nwhy Docker1.Docker 可以让基础架构和应用程序分离，这样可以快速交付软件。2.Docker可以像管理应用软件一样管理基础架构。3.利用Docker的快速交付、测试和部署方法，可以显著减少写代码和生产环境运行之间的延迟。4.Docker提供工具和平台去管理容器的生命周期。\nhow to use Docker &amp; what to dowhat to do with Docker1.快速一致的发布应用2.响应式的部署和扩容3.相同硬件上更多的工作负载\nDocker 的工作基于容器和镜像，所以需要理解什么是容器和镜像。容器是和机器上其他进程相互隔离的沙盒进程。就是一个可运行的镜像实例。容器镜像就是一个包含了容器运行的文件系统、包括所有依赖、配置、脚本二进制文件等。也包含一些容器其他的配置，包括环境变量、初始运行命令和其他元数据。\ngetting start1.创建一个包含能够构建java镜像需要指令的Dockerfile2.将镜像作为容器运行3.建立本地开发环境，给容器连接数据库4.用Docker Compose 运行这个Spring Boot应用5.用Github Actions为你的应用去配置CI&#x2F;CD管道6.把应用部署到云上\n","tags":["技术研究"]},{"title":"学习agile","url":"/2022/11/09/%E5%AD%A6%E4%B9%A0agile/","content":"什么是agile敏捷是一种迭代式的项目管理和软件开发方法，可以更快为用户提供价值。敏捷团队更小的、易消耗，增量交付工作。持续性的评估需求、计划和结果，因此可以容易更快响应变化。\n如何做适应agile的开发者（三件事情—分支、持续集成、自动测试使得保证代码质量的情况下更有生产力）branching strategy分支策略可能因为团队而改变三种策略： release branching 、 feature branching 、 task branching（issue branching）\nTesting\nCI（agile和devops的最佳实践—持续的build，和自动化测试）主要包含两件事情：确保代码可编译；测试确保代码达到设计的目标持续集成就是持续的向主分支集成改变的代码，同时尽可能频繁和尽早测试改变的代码。CI的好处： 更快的得到代码改变的反馈。\nCI中的测试：Unit test、API test、 Functional tests\n","tags":["技巧"]},{"title":"学习scrum","url":"/2022/11/09/%E5%AD%A6%E4%B9%A0scrum/","content":""},{"title":"为什么我想做软件开发","url":"/2022/11/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E6%83%B3%E5%81%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/","content":"软件开发的特点软件开发是比较要求逻辑性，需要逻辑清晰才能设计出运行良好的程序。开发的过程需要抽象思维，描述过程、总结规律。将事物特性抽象出来，表达出关系，最终可以得到一种自动化的流程或者减少重复的动作。\n我的爱好与特长我认为我比较擅长逻辑思考，推理分析。我学习到一些系统设计，算法设计，数据库设计，最终会得到一个系统，这个过程让我很有成就感。\n我做了什么大学期间期末考试中得出结论，可以通过一定的方法复习，可以轻松的考高分。我喜欢软件设计，所以我尝试做了一些工具性的项目，让我方便去做其他事情，比如算法设计平台，todolist。\n","tags":["我"]},{"title":"未来","url":"/2022/11/10/%E6%9C%AA%E6%9D%A5/","content":"未来的工作做自己喜欢的工作，WLB希望可以对软件开发有所贡献。  开源软件。坚持做一个content creater。\n未来的生活坚持健身、阅读、打理好自己的形象坚持记录生活。\n感想在写这篇文章的时候，我突然感觉，想要未来的样子，也许就是现在没有的样子。规划未来，就是在给现在的自己指导要注重什么，要做什么。\n","tags":["我"]},{"title":"Java语言到Spring框架","url":"/2022/11/11/%E4%B8%AA%E4%BA%BA%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/","content":"为什么总结学习很多技术，总结为了第一方面，加深记忆。第二方面，加深理解。第三方面，提炼出自己的理解，为我所用。\n面向对象Java语言有这么一些概念跟面向对象有关系：面向对象中的六个概念：class类、对象、抽象、继承、封装、多态1、对象：每一个现实世界的实体都是一个对象。 一个对象有行为和属性。 一个汽车可以移动 ，可以用价格，排量，颜色等属性。\n2、类：所有相关的对象的集合就是一个类。类是所有相关对象的集合，出租车、公交车、救护车都属于汽车类。\n3、继承：一个类可以从父类中继承一些特性就好像我们从父母那里也继承了一些特性。 就像手机，可以有子类 移动电话和固定电话  但是这俩都继承了打电话的特性。\n4、封装就是将数据包装到一个单元中，并且保护它将想胶囊一样，将药物颗粒封装起来，与外部环境隔离。银行将存储保存在保险柜里，用密码保护起来。\n5、抽象将复杂度隐藏起来，暴露简单相关的内容。汽车将引擎、很多机械复杂性隐藏卡里， 用户可以用到刹车制动器、加速器、变速箱。\n6.多态多种形式。同样的名字但是有不同的形式。行为名称是一样的，不同对象的行为表现出不一样。就好像下棋，棋子的行为是移动， 但是有的可以沿着对角线移动，有的只能水平和垂直移动。\n设计模式与其在框架中的应用1.工厂模式Spring IOC中用到了工厂模式去创建bean的对象实例\n2.单例模式Spring中Bean的默认为singleton单例模式。\n3.代理模式AOP模块中AopProxy, 用了JDK动态代理和CGLIB的字节码生成技术。\nSpring框架IOC（ioc是设计思想、依赖注入是具体实现）原理以及用到的设计模式，应用场景IOC带来的好处是什么，将对象的控制权和生命周期交给IOC容器，那么这个容器的过程，以及这个对象的生命周期是什么样的IOC的目的是解耦， 项目开发中具体用到IOC是什么场景\nAOP原理以及用到的设计模式，应用场景通过切面技术对业务主体增加额外的通知（advice），从而对声明的切点（pointcut）的代码块进行统一管理和装饰。在某些方法的前后进行一些通用的操作，这些操作本身不会影响程序本身的运行。\nSpring Boot自动配置启动过程原理常用注解\nSpring Boot 与Spring Cloudspringboot 专注于快速开发单个微服务个体；SpringCloud 关注全局的服务治理框架。 将springboot开发的一些单体微服务整合并管理。 提供配置管理、服务发现、断路器、路由、全局锁、分布式会话等集成服务。\n","tags":["个人技能"]},{"title":"如何提升口语交际能力","url":"/2022/11/11/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%8F%A3%E8%AF%AD%E4%BA%A4%E9%99%85%E8%83%BD%E5%8A%9B/","content":"","tags":["个人技能"]},{"title":"MongoDB","url":"/2022/11/12/MongoDB/","content":"是什么面向文档的NoSQL数据库，用于大量数据存储。mongdo的文档结构很符合开发人员编程语言中构造的类和对象。\n为什么用\n面向文档： 数据存储在文档中，使得Mongo非常灵活，可以适应实际的业务环境和需求。\n负载均衡：使用分片的概念，通过多个mongo实例之间拆分数据来水平扩展。可以在多台服务器上运行，以平衡负载或复制数据，以便在硬件出现故障时保持系统正常运行。\n\n集合文档的分组，集合等效于RDBMS中创建的表。集合存在于单个数据库中。\n文档集合的记录。文档包含字段名称和值。mongo将数据存储为一个文档，类似于JSON对象数据由键值对组成，类似于Java的Map\n字段字段包含名称和值。一个文档拥有零个或者多个字段。 字段类似于关系数据库中的列。\n怎么用mongoDB 为了web提供可扩展的高性能数据存储解决方案\n","tags":["数据库"]},{"title":"MySQL","url":"/2022/11/12/MySQL/","content":"数据类型\n字段类型\n整型  TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT\n浮点数  FLOAT、DOUBLE、DECIMAL\n字符串  CHAR、VARCHAR\n时间和日期\n\nDATETIME （1001-9999年）\n\n\n\nTIMESTAMP（从1970.1.1开始的秒数）\n\n\n\n\n\n\n\n常用语法规则与编程技巧多表联查方法：内连接、左外连接、右外连接、全外连接、笛卡儿积外连接就是 查询出相交的部分，还有左边表独有的部分。\nSQL优化常用方法及场景存储引擎\nInnoDBMySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n\nMyISAM不支持事务\n\n\n事务索引 B+数\n数据结构特点\n与红黑树的区别\n\n分库分表主从复制备份与恢复数据库安全\n策略\n管理\n\n","tags":["数据库"]},{"title":"旅行项目","url":"/2022/11/12/%E6%97%85%E8%A1%8C%E9%A1%B9%E7%9B%AE/","content":"为什么做这个想把旅行的一些经历和想法记录下来。\n项目架构与模块\n项目技术栈基于SpringBoot的单体项目，spring security、JPA、MySQL、JWT业务类、登录与注册、认证与授权、数据存储\n\n项目流程注册流程登录流程\n\n\n授权与认证流程\n数据操作流程\n项目遇到的问题项目亮点","tags":["项目经验"]},{"title":"微服务项目","url":"/2022/11/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/","content":"为什么做这个\n为了尝试与学习微服务技术栈（感兴趣所以就尝试去做了）\n微服务的项目模块的特性是将一个个的业务分离开，方便维护和复用。于是我自己不断的积累开发微服务模块，就可以不断的积累，构建一个功能更全面，实用性更强的系统。\n\n项目架构项目技术栈SpringBoot、SpringCloud gateway、注册中心Eureka、Prometheus系统监控、Docker容器化\n网关的登录与路由、服务注册与发现、应用容器化、系统监控\n流程网关路由流程服务注册中心流程容器化过程系统监控流程\n项目遇到的问题项目亮点","tags":["项目经验"]},{"title":"Java面试题","url":"/2022/11/13/Java/","content":"继承\n访问权限\n接口与抽象类\nsuper\n重写与重载\n\n抽象类抽象类 和抽象方法 需要用abstract 关键字声明。 抽象类一般包含抽象方法。抽象类和一般类的区别在于抽象类不能被实例化。\npublic abstract class AbstractClassExample &#123;    protected int x;    private int y;        public abstract void func1();        public void func2() &#123;        System.out.println(&quot;func2&quot;);    &#125;&#125;public class AbstractExtendClassExample extends AbstractClassExample &#123;    @Override    public void func1() &#123;        System.out.println(&quot;func1&quot;);    &#125;&#125;// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiatedAbstractClassExample ac2 = new AbstractExtendClassExample();ac2.func1();\n\n使用抽象类：\n\n需要多个相关的类中共享代码。\n需要能控制继承来的成员的访问权限，并不都是public。\n需要继承非静态和非常量字段。\n\n接口接口是完全抽象的类，在 Java8之前， 就是不能有任何的方法实现在Java 8开始，接口可以拥有默认的方法实现，因为不支持默认方法的接口维护成本太高了。\n接口的成员（字段+方法）都是默认public，并且不允许定义为Private 或 protected。\n接口的字段默认都是 static 和 final 的。\npublic interface InterfaceExample &#123;    void func1();    default void func2()&#123;        System.out.println(&quot;func2&quot;);    &#125;    int x = 123;    // int y;               // Variable &#x27;y&#x27; might not have been initialized    public int z = 0;       // Modifier &#x27;public&#x27; is redundant for interface fields    // private int k = 0;   // Modifier &#x27;private&#x27; not allowed here    // protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here    // private void fun3(); // Modifier &#x27;private&#x27; not allowed here&#125;public class InterfaceImplementExample implements InterfaceExample &#123;    @Override    public void func1() &#123;        System.out.println(&quot;func1&quot;);    &#125;&#125;// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiatedInterfaceExample ie2 = new InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x);\n\n使用接口\n\n需要让不相关的类都实现一个方法，例如不相关的类都实现Comparable接口中的compareTo()；\n想要确定特定数据类型的行为，但是不关心谁实现这个行为。 \n需要使用多重继承。\n\n抽象类与接口区别使用上来说，一个类可以实现多个接口，但是不能继承多个抽象类。接口的字段 只能是static 和final类型，抽象类没有限制。接口成员只能是public，抽象类成员可以有多种访问权限。\n选择：很多时候，接口优于抽象类，因为接口没有抽象类严格的类层级结构要求，可以灵活为一个类添加行为。 并且从Java8开始，接口也可以有默认的方法实现，使得修改接口的成本很低。\n重载和重写重写（override）发生在继承关系中，子类实现父类方法声明完全相同的方法。为了满足里氏替换原则有两个限制：\n\n子类方法的访问权限必须大于等于父类方法。\n子类方法的返回类型必须是父类返回类型或者其子类型。\n\n使用@Override注解，可以让编译器帮忙检查是否满足以上两个条件。\n重载（overload）存在于同一个类中， 一个方法与已经存在的方法名称上相同，但是参数类型、个数和顺序至少有一个不同。但是 返回值不同，其他都相同不算重载。\n","tags":["Java"]},{"title":"Java常见的异常","url":"/2022/11/13/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/","content":"常见异常类型\nNullPointerException 空指针异常\nArrayIndexOutOfBoundsException 索引越界异常\nInputFormatException输入类型不匹配异常\nSQLException SQL异常\nIllegalArgumentException 非法参数异常\nNumberFormatException 类型转换异常\n\n异常解决方法Java内建了通用的异常，以Throwable为顶层父类。Throwable派生出Error和Exception类。\nError：Error类以及子类的实例，代表JVM本身的错误，不能被程序员通过代码处理。Exception：Exception以及子类，代表程序运行时发送的各种不期望发生的时间。可以被java异常处理机制使用，是异常处理的核心。\n处理方法\ntry catch\ntry&#123;// 程序代码&#125;catch(ExceptionName e1)&#123;//Catch 块&#125;\n\nthrowthrow 关键字作用是抛出一个异常，抛出时候是抛出一个异常类的实例化对象，在异常处理中，try语句捕获的就是一个异常对象，那么异常对象也可以自己抛出。\n\nthrows定义一个方法的时候可以用throws关键字声明。使用throws关键字声明的方法表示此方法不处理异常，而交给方法调用着进行处理。\n\n\n异常的层次结构Java通过API 中Throwable类的众多子类描述各种不同的异常。Java异常都是对象，是Throwable子类的实例。\n\nThrowable包含两个子类：Error(错误) 和 Exception（异常）包含了线程创建时线程执行堆栈的快照，提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。\n\nErrorError类及其子类： 程序中无法处理的错误， 表示运行应用程序中出现了严重的错误。一般表示运行时JVM出现问题。 通常由Virtual MachineError 虚拟机运行错误， NoClassDefFoundError（类定义错误）。OutOfMemoryError：内存不足错误；StackOverflow： 栈溢出错误。 此类错误发生时， JVM将终止线程。\n\nException程序本身可以捕获并且可以处理的异常。Exception分为两类：运行时异常和编译时异常。\n\n\n\n运行时异常 RuntimeException类和其子类异常，如NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常），这些异常是不检查异常，程序可以选择捕获，也可以不处理。这些异常一般由程序逻辑错误引起。 Java编译器不会检查它， 程序中可能出现这类一场，即使没有捕获或者抛出，也会编译通过。\n\n\n非运行时异常(编译异常)除了RuntimeException之外的异常，类型上属于Exception类及其子类。程序语法角度必须进行处理的异常，如果不处理，程序不能编译通过。如IOException、SQLException等用户自定义的Exception异常，一把情况下不自定义检查异常。\n\n可查异常和不可查的异常\n可查异常（编译器要求必须处理的异常）在一定程度上它的发生是可以预计的，一旦发生，必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都是可查异常。这类异常的特点是编译器会检查，（非运行时异常）。当程序中可能出现这类异常，要么try-catch语句捕获它，要么用throws 子句抛出它，否则编译器不通过。\n\n不可查异常（编译器不要求强制处理的异常）包括运行时异常（RuntimeException与其子类）和错误（Error）。\n\n\n","tags":["Java"]},{"title":"Java数据类型","url":"/2022/11/13/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"大分类基本数据类型 8个， 引用类型 3个\n基本数据类型\nbyte（8）、short（16）、int（32）、long（64） 属于数值型中的整数型\nfloat（32）、double（64）属于浮点类型\nchar（16） 属于字符型\nboolean（1） 属于布尔型\n\n引用数据类型类、接口、数组\n包装类java的8个基本数据类型，分别对应8个包装类，包装类型和基本类型之间的赋值通过自动装箱与拆箱完成。\n\nbyte – Byte\nboolean – Boolean\nshort – Short\nchar – Character\nint – Integer\nlong – Long\nfloat – Float\ndouble – DoubleInteger x = 2;     // 装箱int y = x;         // 拆箱\n\n为什么要包装类\n基本数据类型简单，但是不支持泛型和集合。\n不符合面向对象思维。\n包装类提供很多方法，方便使用。如：Integer类toHexString（int i）、parseInt（String s）等。\n\n","tags":["Java"]},{"title":"Linux与shell脚本","url":"/2022/11/12/Linux%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/","content":""},{"title":"计网应用token、cookie和session","url":"/2022/11/12/%E8%AE%A1%E7%BD%91%E5%BA%94%E7%94%A8token%E3%80%81cookie%E5%92%8Csession/","content":"session 和cookie 和token分别是什么session 是基于Cookie实现的一种记录服务端和客户端会话状态的机制。Session存储在服务端。 SessionID 会被存储在客户端的Cookie中。\nsession 和cookie 和token分别为什么cookie在HTTP&#x2F;1.1 引入cookie来保存状态信息，使得http协议尽可能的简单。随着现在浏览器的存储方式，cookie逐渐被淘汰。\nsession 和cookie 和token应用场景cookie\n\nsession management 会话管理登录、购物车、游戏分数等 任何服务器来存储的数据 \npersonalization 个性化用户偏好、主题 和其他设置\ntracking 跟踪记录和分析用户行为\n\nsession 和cookie 和token区别","tags":["项目开发"]},{"title":"Java对象引用","url":"/2022/11/15/Java%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/","content":"什么是引用数据类型引用数据类型是 在创建的时候，会先在堆内存中分配一块空间，存储对象的具体信息，然后在栈中存储该对象的地址信息。\n引用的类型\n强引用  垃圾回收器不会回收被引用对象，哪怕内存不足，JVM会直接抛出OutOfMemoryError，除非赋值为null；\n软引用  描述一些非必需但仍有用的对象。在内存足够时，软引用不会回收，只有在内存不足时，系统回收。\n弱引用  无论内存是否足够，只要JVM进行垃圾回收，那些被弱引用的对象都会被回收。\n虚引用  主要用来跟踪对象被垃圾回收器回收的活动。  无法通过虚引用来获取对象。虚引用必须和（ReferenceQueue）引用队列一起使用，NIO的堆外内存就是靠其管理。\n\n","tags":["Java"]},{"title":"Java常用集合与实现","url":"/2022/11/15/Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E4%B8%8E%E5%AE%9E%E7%8E%B0/","content":"HashMap\n1.8版本的变化\n\n\n加入红黑树\n插入数据方式变为尾插法、\nhash值计算方式变为2次扰动处理（1次位运算+1次异或）\n扩容策略变化，插入后再扩容\n\n\n线程不安全：1.7中，扩容采用头插法，可能出现循环链表，为了修复改为尾插法。HashMap任意版本中，如果在插入数据时多个线程命中了同一个槽，可能数据覆盖的情况，导致线程不安全。\n\n线程不安全解决方案\n\n给HashMap直接加锁\n使用Hashtable，比方法1效率高，原理是在方法上加Synchronized锁\n使用concurrentHashMap，本质是减小了锁的粒度，减少线程竞争，更高效。\n\n\n与concurrentHashMap的区别\n\nConcurrentHashMap版本区别：\n\n1.7 锁粒度 基于segment  1.8基于entry节点\n1.7锁用reentrantLock   1.8用synchronized\n底层结构1.7 segment  + HashEntry + Unsafe  ； 1.8 Synchronized + CAS + Node + Unsafe\n\nArrayList &amp; LinkedList（双向链表）\n对于随机访问，ArrayList 优先，因为基于数组实现，存储空间连续，支持随机访问\n对于新增和删除数据，LinkedList优先，因为ArrayList要移动数据。\n同样数据量LinkedList所占空间更小，ArrayList需要预留空间便于后续数据增加，而LinkedList只需要增加一个节点。\n\nHashSetset继承于Collection接口，不允许出现重复元素，并且无序。HashSet基于HashMap实现，底层用HashMap保存元素。元素哈希值通过元素hashcode方法来获得，首先判断hashcode，之后判断equals，如果都相同视为同一个元素。\n","tags":["Java"]},{"title":"Java对象的生命周期","url":"/2022/11/15/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":""},{"title":"Java版本特性","url":"/2022/11/15/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/","content":"1.8函数编程（lambda表达式）\n11将提供长期支持服务，将作为Java默认支持版本。指导2023年9月从8 到 11\n\n语言新特性\n新工具和库更新\nJVM优化\n\n","tags":["Java"]},{"title":"Spring中Bean的生命周期","url":"/2022/11/15/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"Bean初始化的大致4个阶段\n实例化（instantiation）\n属性赋值（populate）\n初始化（initialization）\n销毁（destruction）\n\n涉及到的扩展点的作用\nAware接口通过让Bean实现Aware接口，在bean中获取响应的Spring容器资源。\nBeanPostProcessor是Spring修改Bean提供的强大扩展点，可作用于容器中所有Bean。\n\n","tags":["Spring"]},{"title":"动态代理与反射","url":"/2022/11/15/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/","content":"反射什么是反射？哪里用到了反射？怎么用的？反射原理？\n","tags":["Java"]},{"title":"如何准备一场视频面试","url":"/2022/11/15/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E4%B8%80%E5%9C%BA%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95/","content":"搜集相关问题及解决方案组织回答问题的语言模拟面试录像，对回答问题的形式和内容进行修正和补充。\n修正与补充重复以上步骤","tags":["技巧"]},{"title":"认证与授权","url":"/2022/11/15/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/","content":"链接https://javaguide.cn/system-design/security/basis-of-authority-certification.html#%E8%AE%A4%E8%AF%81-authentication-%E5%92%8C%E6%8E%88%E6%9D%83-authorization-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\n","tags":["软件开发理解"]},{"title":"JVM","url":"/2022/11/16/JVM/","content":"JVM 、JRE和JDK\nJVM  java运行在虚拟机上，在不同的平台上有不同的虚拟机，从而实现跨平台。\nJRE  java运行环境，包含JVM和核心类库，如lang包：系统类、包装类型、基本数学函数、字符串处理、线程、异常处理类等。 如果只要运行java，安装JRE就行。\nJDK  包含JRE和一些开发工具，如JAVA.exe、JAVAc.exe、Jar.exe java运行、编译和打包工具等。\n\n工作过程作用 ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的解释器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n\n内存模型（深入理解）线程私有：栈、本地方法栈、程序技术器线程共享：堆、方法区\n类加载机制（了解）GC（了解）内存可见性","tags":["Java虚拟机"]},{"title":"how to add a feature?","url":"/2022/11/19/how-to-add-a-feature/","content":""},{"title":"how to build a feature?","url":"/2022/11/19/how-to-build-a-feature/","content":"Documentations\nunderstand the project structure and parrterns.\ncode standards and best practices.\n\nRun the project\ntry to use the project, try the existing functions.\n\nUnderstand the features\nlearn about the feature’s requirements.\n\nUnderstand the structure of code\nto figure out where(which package, which layer) your feature’s code belong to.\n\n","tags":["软件开发理解"]},{"title":"hexo 与 分布式文件系统","url":"/2022/11/24/hexo-%E4%B8%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"分布式特点：并行处理：多台机器同时处理同一功能节点可以访问系统中其他节点并与之通信。\n微服务微服务是分布式系统，将应用分解为单独的组件或“服务”。系统拥有服务的多个冗余副本，服务不会出现集中故障点。更具组合型，可以重复利用小型服务节点提供的功能。微服务更加稳健，可实现更灵活的的垂直和水平扩展。\n","tags":["分布式"]},{"title":"hashcode 和 equals","url":"/2022/11/20/hashcode-%E5%92%8C-equals/","content":"为什么要重写方法默认的hashcode 和 equals方法都是继承自Object类中。equals方法去判断两个对象引用的地址是否相同。\n在一般情况中，比如创建了两个用户对象，参数相同的情况下，equals方法对比，结果为false。因为是new出来的两个对象，引用指向的地址一定不同，所以equals结果为false。\nhashcode也不同。 放入map或者set中时，两个相同的对象，却会重复出现两次。违背了map和set的特性。本来想要像个相同的对象判断成了不同的对象，为了达到目的，让我们认为两个相同的对象判断也是同一个对象，所以需要重写原来的hashcode和equals方法。\n原因：set根据hashcode 是否相同，在判断equals是否相同来判断是否为同一个对象。map根据key值的hashcode值分配和获取对象保存数组下标，然后根据equals判断是否唯一。\n什么时候重写如何重写只重写equals方法也不行，因为在集合中判断两个对象是否相同时，会用到hashcode方法，所以重写equals同时也要重写hashcode方法。\n","tags":["Java"]},{"title":"数据库","url":"/2022/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"事务ACID特性事务是由一系列数据库操作组成的一个完整的逻辑过程。如银行转账。一个完整的逻辑过程，不可拆分，这个过程叫事务。 具有ACID特性。\n\n原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成。\n一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。\n隔离性：隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n事务隔离的级别：（）\n\n读未提交（Read uncommitted）：脏读、不可重复读、幻读都可能出现\n读提交（read committed）： 可以避免脏读。\n可重复读（repeatable read）：避免脏读、不可重复读，但是会幻读。\n串行化（Serializable）：性能很低、事务顺序执行、避免脏读、不可重复读、和幻读问题。隔离级别从低到高，性能逐渐减低、但是事务数据一致性增高。\n\n脏读、不可重复读、幻读\n\n脏读：事务2查看了事务1未提交的更新事务，结果事务1回滚了，就是脏读。\n幻读:  事务2在事务1的两次查询之间插入了新的值，导致两次数据（条数、量）不一致。\n不可重复读：事务2在事务1的两次查询之间更新了新的值，导致查询结果不一致。\n\n手写常用语句条件查询关联查询排序查询分组查询逻辑关键字常用函数（count、sum、order by）\n数据类型整数型浮点型字符串二进制时间\n存储引擎（特点）MyIASM      支持全文检索，查询效率高；  不支持事务， 使用表级锁InnoDB        支持ACID事务，支持外键、行级锁， 使用行级锁，提高了并发效率\n锁\n表锁粒度大，锁冲突几率大，\n行级锁锁的粒度小，并发冲突几率低，并发效率高\n共享锁\n排他锁\n\n索引大幅增加数据库的查询性能，需要额外的空间来存储索引，适合应用到读多写少的场景。\n\n类型：\n\n\n唯一索引\n\n主键索引 不允许空值\n\n普通索引\n\n联合索引 注意最左原则\n\n全文索引 （MyISAM）  5.6版本之后 InnoDB也实现了全文索引\n\n\n\n索引实现\n\n\nB-Tree\nR-Tree\nHash  散列表 效率高，但不支持范围查找，实际使用较少。\nFullText 记录关键字与对应文档的倒排索引\n\n存储过程与函数避免重复编写语句\n\n存储过程\n\n函数\n\n\n新特性（8.0）隐藏索引、通用表表达式、窗口函数（）\n优化\n表结构与索引\nSQL语句优化\n参数优化\n硬件及系统配置优化成本逐渐升高，但是优化效果 逐渐降低\n\n\n表结构与索引优化\n\n\n分库分表，读写分离\n为字段选择合适的数据类型， 尽可能小\n字段多的表分解成多个表\n为经常使用查询的创建索引\n列字段尽量设置not null\n\n\nSQL语句优化\n\n\n找到最需要优化的查询语句：使用频率最高、优化后提高最明显的语句。（分析慢查询日志）\n使用分析工具：explain、profile\n避免使用Select * ，指定需要获取的字段（避免查询列字段的元信息）\n尽量使用prepared statements （性能更好、防止SQL注入）\n使用索引扫描来排序\n\n","tags":["计算机基础"]},{"title":"操作系统","url":"/2022/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":""},{"title":"英语学习心得","url":"/2022/11/24/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/","content":"前言英语学习 和其他很多学习一样， 持之以恒，每天学一点，当天不会感觉到什么，当坚持做了很久之后，就会感觉到自己能听懂了， 自己能读好了， 自己能说出来了， 自己能运用。\n","tags":["英语"]},{"title":"计算机网络","url":"/2022/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"4&#x2F;7层模型TCP 协议\n基于链接 （点对点）\n双工通信\n可靠传输（基于字节流，将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制，保证接收数据的有序性和完整性。）\n流量控制，滑动窗口控制数据的发送速率，滑动窗口的本质是数据的动态缓冲区，接收端根据自己的接收能力在Header中动态调整窗口大小，通过ACK应答包通知给发送端，发送端根据窗口的大小调整发送的速度。\n拥塞控制： （四个算法：慢启动、拥塞避免、拥塞发生、快速恢复）报文状态三握四挥keepalive滑动窗口 进行流量控制\n\nHTTP协议：Method、Header、Cookies状态码HTTPS 交互流程HTTP 2.0  多路复用、Stream、流量控制、服务端推送\nUDP","tags":["计算机基础"]},{"title":"编译原理","url":"/2022/11/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","content":""},{"title":"分布式系统","url":"/2022/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","content":""},{"title":"Distributed System Engineering lecture 1","url":"/2022/11/30/Distributed-System-Engineering-lecture-1/","content":"what is this lecture all  about？big view on the distrubuted system,consistency-performance-fault tolerance\na study case on MapReduce about how it works, \n","tags":["distributed system"]},{"title":"ToDoList","url":"/2022/12/31/ToDoList/","content":"为什么做用来记录和规划每天要做什么事情，更高效的完成想要去做的事情。\n项目架构前后端分离- 后端：SSM + MySQL\n为什么用了数据库？一般来说，todo可以不具备记忆功能，或者记录很少的东西，可以放在浏览器的localstorage。\n项目模块后端模块设计：\n\n用户注册与登录\n话题模块\n任务模块\n\n项目中遇到的问题Description:\nParameter 1 of constructor in com.example.todolist.service.AuthService required a bean of type ‘org.springframework.security.authentication.AuthenticationManager’ that could not be found.\nAction:\nConsider defining a bean of type ‘org.springframework.security.authentication.AuthenticationManager’ in your configuration.\n找不到对应的Bean，但是这个Bean是在Security包中的。\n项目亮点技术亮点业务亮点业务亮点就是 每个任务会有一个预估的完成时间，用户可以去执行任务的时候开启倒计时功能，倒计时结束时，表示用户完成了任务；当用户完成一个话题的相关所有任务的时候，这个话题会进入已完成的话题列表，很有成就感。\n","tags":["项目经验"]},{"title":"CAS 原理与应用","url":"/2022/12/07/CAS-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","content":"CAS原理（对比 交换）优缺点应用场景","tags":["并发"]},{"title":"用户注册与登录","url":"/2022/12/31/%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95/","content":"用户登录实现方法后端的输入与输出输入：用户名和密码、手机号和密码后端通过查询用户表对照用户输入的信息是否正确来认证用户身份。如果身份验证通过，后端给用户返回一个Token，ID，用户持有这个ID或者Token来进行接下来的系统访问操作。\n","tags":["项目开发"]},{"title":"JWT的原理与使用","url":"/2023/01/09/JWT%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"作用要用一个技术&#x2F;框架，首先是我想做一件事情，这个技术&#x2F;框架可以方便我做这件事情。所以我选择使用这个技术&#x2F;框架。JWT 用于各方之间以JSON对象安全传输信息，这些信息通过数字签名进行验证和授权。可以使用“RSA”的“公钥&#x2F;私钥对”对JWT进行签名。\n基本使用过程JWT请求过程\n\n使用使用浏览器发送用户名和密码\n服务器使用私钥创建一个JWT\n服务器返回JWT给浏览器\n浏览器将JWT串在请求头向服务器发送请求\n服务器验证JWT\n按授权规则返回资源给浏览器前3步获取了JWT之后，在JWT有效期内，直接进去4-6步来请求资源即可。\n\nJWT组成（核心概念）格式：Header、Payload、Signature三部分组成\n实例应用配置、处理注册、处理登录、多方式注册和登录\n","tags":["技术研究","项目开发"]},{"title":"认证授权框架的选择","url":"/2023/01/09/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E9%80%89%E6%8B%A9/","content":"认证授权框架因为最近在做一些项目，都是自己从头开始写登录注册，所以想着应该学习应用一下这些安全框架来实现鉴权的功能才靠谱。所以来学习这些框架技术。\n目前已经了解到的SpringSecurity， shiro。 相对来说Shiro更容易入门一些，因为shiro对于认证授权这些功能的API使用起来相对更简单一些。在国内的受欢迎程度更高一些。昨天发了一个帖子说如何选择SpringSecuriy 和 shiro，有人说这俩都是老古董了，看看新的，sa-token。\n去github搜了一下sa-Token，轻量级的，要做简单优雅的鉴权框架。\n使用体验\nSpring Security以前跟着视频学习项目的时候使用到过Security的，因为当时没有提前了解过该框架的一些核心、常用组件和基础知识，所以很多代码觉得很陌生，难以理解。（后来意识到，使用这个框架之前还是最好先了解一下框架的架构模块、核心概念&#x2F;功能、核心类库、常用方法和流程。了解了这些就不会在使用框架时一头雾水了。）\n\nsecurity的使用体验就是感觉需要大量的配置，在配置中解决问题。\n","tags":["软件开发理解"]},{"title":"最近在做什么001","url":"/2023/01/09/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88001/","content":"idea很有意思，想这之后回顾自己最近在干什么是一件很有意思的事情，于是开始记录自己最近在做什么。\n在做什么\n在技术网站上发帖子，请求一些技术问题，得到了很多回应。\n最近组建了一个项目开发的小团队，想要让自己投身到合作软件开发中。 \n因为开发的时候，我目前就是从0开始，需要做注册与登录，所以顺便需要学习一下认证与授权这种安全框架。\n\n感想与收获\n互联网是很好的学习平台，如何充分利用互联网来学习和成长是很有价值的问题。\n最近在技术网站比较活跃，所以遇到很多大佬。大佬给我的感觉：（大佬在做的事情，也是成为大佬的必经之路）\n\n\n很会包装自己，能让人快速认识这个人，很多经历，让人感觉很厉害。\n大佬通常有很多产出，也是在技术社区相当活跃的一批人，有自己的各种媒体或者github日常贡献很密集。\n大佬通常会做知识分享。\n\n","tags":["最近在做什么"]},{"title":"我常做的事","url":"/2023/01/09/%E6%88%91%E5%B8%B8%E5%81%9A%E7%9A%84%E4%BA%8B/","content":"逛技术社区因为自己打算在IT行业长期发展，所以就想着把自己学习和一些感悟什么的记录下来，这样在以后的一些时刻就可以回头来看到自己一路走来的样子。\n做着做着就把一些东西分享出来，比如学习技术，就拿出来和大家讨论，一些技术问题也会拿到技术社区去发帖子提问题。因为基本上都会得到回复，而且有时候一些人的评论和回复会很有帮助。所以逐渐的在技术社区也活跃起来了。\n了解到很多厉害的人都在技术社区里面有很多帖子或者文章来发表自己的理解和感悟。他们往往有很多产出，也认识更多厉害的人。所以我认为这是一个很有价值的事情。我要朝着这个方向发展。\n","tags":["我"]},{"title":"把握工作与生活的边界","url":"/2023/01/09/%E6%8A%8A%E6%8F%A1%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E7%9A%84%E8%BE%B9%E7%95%8C/","content":"为什么想写我很容易是没有边界感的人，生活和工作没有边界。我认为这不是好事，让我很累。最近在技术社区活跃了，就会看到很多人比我厉害，就发现很多自己可以做的事情，来提升自己，追赶他们的脚步。 但是这个差距不是一天两天能补上的，我不能把自己拿来和别人比较。这会让人心态不稳定，容易带来负面情绪。我要做的事情是把更多的注意力放在自己身上。看到自己的成长路径，看到自己想朝哪里发展，看到自己想要什么，自己需要什么，补充自己的不足，加强自己的力量。\n每个人是不一样的，我能做的是看到自己的在哪里，看到自己的能力，让自己变强，可以参考业界厉害的人，知道自己在遇到一些问题的时候如何来应对。 这样不会太累，也能让自己保持自信。\n阅读了一本书最近看到一本书《弹性习惯》 生活就像大海，不断的变化，我在生活中要面临不断变化的海浪。 那么我对自己的要求和标准就必须要灵活。这样才能应对这些变化，而不至于让变化来挫伤我。\n负面的习惯会让人陷入负面的循环，很难踏出去。我知道我想要去做一些事情，让自己活成想要成为的样子。 可是陷入负面循环的我，就是很困难去做任何改变。\n本书作者另一个著作《微习惯》。 养成习惯就是坚持做一件事情。 很多人之所以没能够坚持多久，因为他每天给自己要求做什么事情，如果没做到就惩罚自己，或者就贬低自己。这是一种外力的控制。     真正的习惯养成，自律，需要来源于自发的动力，源于自己的内部，一种源源不断驱动力，这种力量才是养成习惯，达到自律的重要的条件。  一个容易坚持的习惯，每天哪怕做很微小的事情，但是做到了就会获得成就感。 微小的事情，长期坚持、积累下来就会有明显的感觉，感觉到自己的改变。\n一个不成熟的终身学习者我认为我是一个终身学习者，我好奇心很强。我愿意学习新的东西。所以我学了很多技术。这是不够的，有天赋，可以学的很快，理解一些也许别人理解不了的东西，但是没有辛苦的训练，没有用。\n利用微习惯加弹性习惯， 帮助自己调整和培养更适合自己的学习习惯，让生活感到轻松的，让身心更健康的学习习惯和生活习惯。\n终身学习者是学习、好奇心、成长的动力会伴随他的一生。 他可以一直这么做下去，已经成为他的习惯。这本来是一个好的习惯，但是如果没有边界感，会感到疲惫，会伤身体，学习效果也没有那么好了，从而打击了学习的积极性，变得消极，不愿意学习。好的习惯却给生活带来了坏处，这就是没有边界干带来的问题。 所以我认为我现在是一个不成熟的终身学习者。  而这个问题的核心在于理清楚生活和工作的边界， 享受学习带来的乐趣，带来的成长，同时能够感受到学习改善了我生活，从而让我更好的享受生活。 学习是为了更好的生活，终身学习更是为了更好的生活。\n","tags":["思路总结"]},{"title":"2023年技术学习计划","url":"/2023/01/09/2023%E5%B9%B4%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","content":"起源想起来写这个年度计划，因为最近常常活跃在技术社区，看到很多人记录博客和分享。 今天早上在GitHub个人主页上写下了今年想要学会的技术。于是想这就在这里规划一下自己这一年的小目标，到时候看看自己能做多少。增加点乐趣。\n职业规划目前来说还没有入行，没有接触过真实的企业开发是什么感觉。 对于技术的运用呢，就自己做一点demo，最近开始和一些朋友一起做实践项目玩一玩。 能简单使用尽可能简单。\n对于技术的学习比较认同之前遇到一个面试官给到的建议：觉得现在的技术不足以解决遇到的问题的时候，就是学习使用新技术的时候。 另外一个就是去学习、探索自己感兴趣的技术。\n对于目前处于小白阶段的我，后端技术栈虽然没有所有的技术都体验一遍，但是大体上一个完整的项目开发生态系统已经基本有过使用的体验了。 像很多人一样，我对自己的规划就是在入行初期主要发展自己的广度，让自己有更多发展的可能性。 也许遇到很感兴趣的东西，自己深入研究，实力允许的情况下就可以专心在那个专业领域去发展了。\n我对于技术广度的看法技术广度就在于今天做项目要开发一个需求，可能遇到了不那么熟悉的领域&#x2F;技术，但是我了解这种场景我可以使用到什么技术，可以参考哪些业界的实现方案。\n所以得到广度的两种角度： 一个是技术栈的广度，另外一个是经典场景问题的解决方案。\n\n技术栈的广度\n\n\n对于一个新技术的学习我目前的理解是 需求驱动。我项目中需要鉴权这个功能，那么我可以采用安全框架， 选择好了框架之后，我需要了解这个框架的核心概念（这些核心概念如何对应到我的功能里面），框架的工作原理（这些核心概念是如何配合起来解决问题的）、框架核心模块（框架这些核心功能都是哪些模块提供的），实例应用（动手实现等细节问题）。 掌握了这4个点，我认为自己对于这个技术框架有了一些了解了， 剩下就是在使用中积累，也许阅读源码来加深理解去更好的应用这个技术框架。\n\n\n经典场景的实现方案\n\n编程语言\nPython\nJavaScript\nNode.js\n\n数据库\nMongoDB\nRedis\n\n开发框架\nVue.js\nDjango\\Flask\n\nORM\nMyBatis\nHibernate\n\n中间件\nZookeeper\nDubbo\nNginx\nRabbitMQ\nKafka\n\n开发工具\nPostman\nSwagger\n\nDevops工具（部署和管理应用）\nDocker\nKubernetes\nGit\n\n开发理论和流程\n敏捷开发\n测试驱动开发 TDD\n持续集成和交付 CI&#x2F;CD\n设计模式\n\n学习进度\n设计模式： 观察者\nJS&#x2F;Python 基础\n目前语言基础差不多，深入学习，看书\n中间件学的不多，计划在学习开发技术的同时也要趁着回顾写文档的时候研究一下理论方面的知识。\n开发很多东西涉及到网络协议，网络协议要再学习。\n\n","tags":["我","个人技能"]},{"title":"英语学习工具","url":"/2023/01/11/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/","content":"学习软件最近用的一款软件 叫多邻国，这个软件给人的感觉就是学习英语像是在玩游戏。软件中带有一套激励系统。 激励用户不断的去完成任务，使用软件。 这对用户和软件来说是双赢。\n学习过程中会不断的得到鼓励、学习完之后会得到积分奖励、会获得经验值，经验值会拿来排名，排名靠前的会升级段位。\n针对性练习想要学得快，针对性训练很重要， 前几天学到一个思想，就是输出会带动输入。 所以针对目标，使用英语，这样就知道自己需要什么，不足在哪里，再针对性的学习和补充。\n","tags":["英语"]},{"title":"我现在的技术水平1/11","url":"/2023/01/11/%E6%88%91%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%B0%B4%E5%B9%B3001/","content":"为什么写因为回看自己的技术水平，会看到自己这一段时间的进步，不管进步多少，可以算是对自己这一段时间的一个反思和总结。调整或保持自己的节奏。\n开发技术这段时间因为和朋友一起做项目，开始触及到了一些知识盲区， 根据需求去学习确实很有动力和效率。还有一点就是感受到了 技术的长进是一点一滴的积累。所以在职业生涯中也要注重意识和思想的成长积累。 不然就感觉自己进步很慢，产生焦虑感。\n回到正题， 目前专心于Java开发， 在项目中很少用到Java语言的一些特性，说明项目做的太浅了。最近项目涉及到了一些Java集合的知识，所以就想Java特性还是要再熟悉一下。反复回顾。\n目前Java学习技术栈技术栈是很经典的，网上学习资料的集合体：Java、MySQL、Spring、SpringMVC、SpringBoot、MyBatis、MyBatisPlus这些是开发中常用的技术\nRedis、MongoDB、RabbitMQ、SpringCloud、SpringSecurity、Zookeeper、Ngnix、Docker、JPA、React这些是学习过，写过DEMO的技术\n了解但没用过：Dubbo、K8s、Shiro、ElasticSearch、Solr、ELK\n看过源码：Java（基础类库、集合、并发）深入学习过原理：Java、MySQL、Spring、SpringMVC\n掌握一个技术的标准了解其应用场景、核心概念、工作原理&#x2F;流程、核心模块、实例、将它用到项目中。\n","tags":["我","个人技能"]},{"title":"不知道要做什么的时候应该做什么","url":"/2023/01/11/%E4%B8%8D%E7%9F%A5%E9%81%93%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88/","content":"为什么写最近把上一个项目基本上是做完了初始版本，后续就是维护和优化了。目前不知道要干啥，觉得做事情要找到动力，所以想找到一个理由，让自己有动力去做事情。\n回顾归去、看未来不知道要做什么的时候，就去看之前的收藏夹，就去看之前写的文章和博客，就看看以前的东西。不知道要做什么的时候，就去想想未来想成为什么样的人，想做什么样的事情，就知道自己该干什么了。\n","tags":["最近在做什么"]},{"title":"读书项目开发流程","url":"/2023/01/11/%E8%AF%BB%E4%B9%A6%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/","content":"项目开发规划前端 做小程序后端未知，先做前端\n前端项目流程模块开发计划：\n\n用户登录&#x2F;注册\n读书管理子系统 （对读书的增删改查）\n\n目前状态： 学习微信小程序开发流程\n后端开发流程数据库设计\nSpringBoot开发插件MyBatis-X\n","tags":["项目经验","项目开发"]},{"title":"我的常用的开发工具","url":"/2023/01/11/%E6%88%91%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/","content":"操作系统\nWindows\nLinux（Ubuntu）\n\nIDE 开发环境Intelli J IDEA\n包管理工具Maven\n项目管理工具Trello\n代码托管平台\nGitHub\nGitee\n\n设计文档工具\nProcessOn\n腾讯文档\nNotion\n\n","tags":["我","个人技能"]},{"title":"做一个独立开发者","url":"/2023/01/11/%E5%81%9A%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/","content":"难题想做一个独立开发者，对于后端程序员来说，跨不过去的坎，就是要学会前端开发。\n为什么做一个独立开发者我有很多idea想要做出来，做成软件看看，但是奈何没怎么花心思去学习前端技术，所以往往是实现不了，前端一写就废。 学会前端是一种信心的建立。\n"},{"title":"如何学习新的开发技术/框架","url":"/2023/01/11/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%96%B0%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF-%E6%A1%86%E6%9E%B6/","content":"为什么学习新技术\n新技术可以更好的解决问题\n想要尝试新的领域\n\n方法\n整体架构总览 — 阅读书籍&#x2F;课程（输入）\n快速上手 — 官方文档 （输入）\n应用&#x2F;深入细节 — 看实例&#x2F;做项目（输出）\n文档总结 — 做实例还是项目完成之后都要写 - 文档记录要贯穿始终，学到的新东西最好记录一下 （输出）\n\n应用思想\n不是学完了才可以用\n找到应用它的切入点\n学完快速上手的基础之后，注意应用它的特性\n先学会使用再去理解原理\n\n实战经验记录（应用上面的方法，分析方法是否可行，自我纠错）Node.js - Express.js框架\n目前\n\n\nNode.js 看着菜鸟教程过了一遍基础，能认识代码，对照文档能编写代码。（输入）\nExpress.js 跟着学习文档教程做了一个项目，但是过程中遇到问题，因为文档版本过时了，安装的框架版本新，一些函数特性不支持了。后续需要针对性对代码修改，也算是深入学习的机会。（输入）\n\n\n接下来打算\n\n\n去官网学习一下新版本特性，跟着来一波快速上手。（输入）\n找本受欢迎的书，熟悉一下这个技术的架构、特性和生态。（输入）\n回归第一个项目，修改一些过时的函数特性，让项目运行起来。（输出）\n写文档总结一下自己的学习过程，遇到的问题，解决的方法，找到的资源。（输出）\n\nPython - Flask框架\n目前做过\n\n\nPython官网学习一些基本语法，能写基本看懂代码，看文档能写简单的代码。（输入）\n配置过Flask开发环境，但是因为一些问题没有跑起来。（输入）\n\n\n接下来\n\n\n找本书看看，技术架构、特性和生态。Flask、Python；（输入）\n做一个TodoList项目。（输出）\n写文档总结一下自己的学习过程，遇到的问题，解决的方法，找到的资源。（输出）\n\nJavaScript - Vue.js\n目前做过\n\n\nJavaScript 跟着文档学习了基本语法，部分特性， 基本能读懂，需要依赖文档来写代码。（输入）\nVue.js 跟着官网文档 学习了基本语法特性等，能读懂，能自己简单写，实现一些特性如组件传值等需要依赖文档。（输入）\n尝试用Vue.js做图片上传的前端，虽然基本样子实现了，但是样式很乱，整个项目的文件架构也不知道要怎么组织，所以觉得需要看书或者跟着视频或文档学一个做项目。（输出）\n跟着文档做了一个完整的项目，学习开发流程，系统架构等。（输入）做了一个TODOlist，主要是写组件，然后把组件集成起来。把学习到的新的记录在之后的总结文档中。\n\n\n接下来\n\n\n跟着文档或者视频做一个完整的项目，学习开发流程，系统架构等。（输入）\n找本书看看，技术架构、特性和生态。JavaScript - Vue.js（输入）\n写文档总结一下自己的学习过程，遇到的问题，解决的方法，找到的资源。（输出）\n\n收获\n技术方面很多技术可以同步学习， 这三个编程语言和框架，我几乎实在同一个月入手开始尝试，基本都能比较舒服的阅读和学习这些技术了。 也许是因为有之前C、C++、Java这一路走来的基础，让我比较简单的可以学习新的编程语言，也感受到了其他语言的特性，会产生新的想法，去思考这个语言用到了什么设计模式。这个框架是什么架构的，这个语言都有哪些部分组成，它擅长做什么。让我在面临需求的时候，可以去选择适合的，选择方便的，选择可靠的技术来做，让我站在更高的维度去思考问题。\n\nWeb开发学习一个新的编程语言，我通常喜欢用它去做一个简单的项目，通过这个项目强化了我对于新技术的理解和拓宽了我对它认知。也让我增加了一个新的，小的项目经验。 我逐渐的开始让自己学习产品思维。我希望做一个独立开发者，我能够具备独立开发一个产品的能力。我会在软件工程的层面去思考这个开发问题。 写文档，我会在有想法的时候写文档，记录和分析这个需求，好像可以做一个软件，我就写需求分析， 系统功能设计， 用户角色， 数据对象模型，系统运行流程， 开发实现，（目前做的软件只有实现， 测试和部署基本没做过， 因为一路走到开发实现的idea不多， 很多在实现的过程中，因为初期设计的问题，或者技术实现的问题，都失败了）。\n\n文档能力现在很喜欢记录文档， 文档就是梳理思路， 让很多东西能有个积累， 有了积累就增加了可靠的稳定的提高的可能。 另外一个看着自己一点一点的学习和进步很有成就感，是持续坚持学习和记录成长的动力，正向循环。\n\n\n","tags":["技巧","读书"]},{"title":"打怪升级","url":"/2023/01/11/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7/","content":"新手村了解地图，做任务，升级，收集武器\n技术栈\nJava后端\nJava全栈\n大数据后端\n\n技术的深入技术的深入 从了解应用场景、了解核心概念-工作原理-了解核心模块-实践\n行业的认知发展问题程序开发者入行前三年先广度发展，广度指的是什么，做什么可以扩展开发者的广度能力？在程序开发者入行前三年，建议先广度发展，这里的“广度”指的是掌握多个不同的编程语言、框架、工具、技术等，以及对软件开发过程的整体认知和理解。这样做的好处是，能够让开发者快速适应不同的项目需求，扩展自己的技术视野，提高自己的技术能力，从而更好地应对未来的挑战。\n以下是一些可以扩展开发者广度能力的建议：\n\n学习多种编程语言：学习一些不同的编程语言，如Java、Python、JavaScript等，可以让开发者更好地理解编程语言的本质、优劣势，了解不同语言的应用场景，从而更好地选择适合的语言来解决问题。\n\n掌握多种开发框架和库：学习多种开发框架和库，如Spring、Django、React、Vue.js等，可以让开发者掌握不同的开发范式和技术栈，对各种开发框架的优劣势有更深入的理解，更好地选择适合的框架和库来解决问题。\n\n学习多种数据库技术：了解不同的数据库技术，如关系型数据库（如MySQL、Oracle）、非关系型数据库（如MongoDB、Cassandra）等，可以让开发者更好地理解不同的数据存储方式，选择适合的数据存储方式来解决问题。\n\n掌握多种开发工具和技术：掌握多种开发工具和技术可以帮助开发者提高工作效率和解决问题的能力。例如，可以学习 Git、Docker、Kubernetes 等开发工具和技术。\n\n参与开源项目：参与开源项目可以让开发者接触到不同的项目和技术栈，了解最新的技术趋势和项目管理经验。同时，参与开源项目也可以让开发者扩展自己的社区和人脉。\n\n参加技术活动和交流：参加技术活动和交流可以帮助开发者了解最新的技术趋势和行业动态，同时也可以扩展自己的社交和沟通能力。例如，可以参加技术论坛、Meetup 活动、开发者大会等。\n\n\n总之，扩展开发者的广度能力需要不断地学习和实践，同时也需要积极参与社区和行业活动，与其他开发者进行交流和分享经验。\n初级开发工程师如何学习一门新技术，并将其应用到自己的项目中？\n确定目标：首先，需要明确为何要学习这门新技术，以及将其应用到项目中可以带来什么价值。例如，可能是为了提高项目的性能、添加新功能或改进用户体验。\n\n学习基础知识：在学习新技术之前，需要掌握其基础知识，包括概念、特点、语法等。可以通过查找相关文档、阅读书籍或参加培训课程来学习。\n\n实践演练：通过练习来加深对新技术的理解和掌握。可以通过编写示例代码、参与开源项目、模仿其他成功项目等方式进行实践。\n\n小步快跑：将学习到的新技术应用到自己的项目中，可以先选择一些小的功能点进行实现，从而逐步掌握新技术。同时，在应用新技术时要注意与已有的技术进行整合和兼容，避免出现冲突或不稳定的情况。\n\n查阅资料和寻求帮助：学习新技术过程中，难免会遇到一些问题或瓶颈。此时，可以通过查阅相关文档、论坛或寻求同事或其他开发者的帮助来解决问题。\n\n\n总之，学习新技术需要付出努力和时间，并且需要结合实践进行深入掌握。同时，要注重整合新技术与已有技术，以实现项目的有效整合和提升。\n编程语言掌握的差不多时，下一步做什么？\n深入学习编程语言\n\n深入学习所学编程语言的底层原理，例如：内存管理、多线程、网络编程等。学习更高级的编程特性和技巧，例如：泛型、lambda表达式、函数式编程等。2. 学习数据结构和算法\n学习数据结构和算法的基本概念和实现，例如：数组、链表、栈、队列、排序、查找等。学习算法分析和设计，例如：递归、分治、贪心、动态规划等。3. 学习开发框架和工具\n学习常用的开发框架和工具，例如：Spring、React、Vue、Django等。掌握开发工具的使用，例如：版本控制、调试器、性能分析工具等。4. 做项目提高实战能力\n参与开源项目或者自己动手实现一个项目，例如：一个网站、一个小游戏、一个工具等。在实际项目中掌握更多的技能和经验，例如：需求分析、架构设计、测试和部署等。对于如何做，可以参考以下建议：\n了解自己的兴趣和擅长领域，选择适合自己的方向进行深入学习和实践。不断学习新技术，扩展自己的技能树。多阅读相关的书籍、文章和博客，向优秀的开发者学习，从他们的代码中汲取经验。在实际项目中不断提高自己的实战能力，不断探索和尝试新的解决方案。持续练习和反思，不断提升自己的编程能力和思维方式。总之，不断学习、实践和反思是提升自己的最佳途径。\n如何晋升？\n技术能力方面：初级开发者更注重编程语言的基础知识和基本的编程技能。中高级开发者需要掌握更高级的编程语言特性和技术框架，能够熟练使用和优化常见的算法和数据结构。\n\n解决问题的能力方面：初级开发者可能会需要较多的指导和帮助，需要通过经验的积累和问题的解决不断提高自己的解决问题的能力。中高级开发者能够更好地独立解决问题，有丰富的经验和良好的解决问题的思维方式，能够更快地找到问题的根源并解决问题。\n\n经验方面：初级开发者缺乏实际项目经验，需要通过学习和实践逐渐积累经验。中高级开发者有丰富的项目经验，能够从以往的经验中快速识别出问题并提供解决方案。\n\n沟通能力方面：初级开发者需要与团队成员和上级经理保持良好的沟通，学习如何表达自己的想法和听取他人的意见。中高级开发者需要更好地沟通和协调不同团队之间的工作，能够扮演更好的角色，与更高级别的管理层合作，向他们解释复杂的技术问题。\n\n领导能力方面：中高级开发者需要具备领导能力，能够领导并协调团队成员的工作，能够在团队中扮演指导、协调、领导等角色。想要晋升的话，需要具备以下能力：\n\n深入学习所在领域的技术，并熟练掌握相关的编程语言和技术框架。\n\n多参与开发项目，积累丰富的项目经验和解决问题的能力。\n\n学会独立思考和解决问题，能够对问题进行分析，找出问题的根源并提供解决方案。\n\n具备良好的沟通和协调能力，与团队成员和上级经理保持良好的沟通和协作。\n\n学会领导和协调团队成员，提升领导能力，为团队成员提供指导和帮助，促进团队的发展和进步。\n\n注重个人的职业规划和发展，定期评估自己的技术能力和职业发展方向，不断学习和探索新的技术和领域。\n\n\n总之，想要晋升的话，需要不断地学习和提高自己的能力，累积丰富的项目经验和技术经验，提升自己的解决问题的能力、沟通能力、领导能力等方面的综合素质，从而成为一名优秀的中高级开发者。\n作为开发者应该如何维护自己的博客和个人网站持续整个职业生涯？维护个人博客和网站可以帮助开发者记录和分享自己的经验和成果，扩展自己的人脉和影响力，提高自己的专业知识和技能。以下是一些维护个人博客和网站的建议：\n1.选择适合自己的博客和网站平台，例如WordPress、GitHub Pages、Jekyll、Hexo等，根据自己的需求和技术水平选择适合自己的工具。\n2.定期更新博客和网站内容，包括技术文章、项目经验、行业趋势、个人成长等方面，保持内容的新鲜度和可读性，吸引更多的读者和关注者。\n3.关注社区和行业动态，参与技术讨论和分享，与其他开发者交流经验和观点，扩展自己的人脉和影响力。\n4.优化博客和网站的SEO和用户体验，包括关键词优化、页面速度优化、内容布局优化等方面，提高搜索引擎排名和用户访问体验。\n5.提供有价值的内容和资源，例如教程、工具、框架、开源项目等，吸引更多的访问者和关注者，提高自己的专业知识和技能。\n6.积极回应和处理读者和访问者的反馈和意见，建立良好的互动和信任关系，提高自己的口碑和声誉。\n维护个人博客和网站需要耗费一定的时间和精力，但可以为开发者带来诸多益处和机会，因此建议开发者在职业生涯中持续地维护和更新自己的博客和网站，分享自己的成果和经验，提高自己的专业水平和影响力。\n开发者如何开发一个新的业务功能，方法论和执行步骤。开发一个新的业务功能需要经过以下步骤：\n1.需求分析：首先，需要明确业务需求，了解用户的需求和期望，确定功能的基本需求和特性，包括功能的输入、输出、流程和界面设计等方面。可以通过和业务方和用户沟通，收集反馈和建议，绘制流程图和原型图等方法来明确需求。\n2.技术选型：根据需求和特性，选择合适的技术栈和框架，例如前端框架、后端框架、数据库、云服务等，确保技术方案的可行性和可扩展性。需要考虑技术选型的成本、风险、安全等方面。\n3.设计实现：根据需求和技术方案，进行系统设计和开发，包括模块划分、接口设计、数据库设计、代码实现等方面。需要遵循良好的编程规范和设计原则，确保代码的可读性、可维护性和可扩展性。可以使用敏捷开发和迭代开发等方法，不断优化和改进设计和实现过程。\n4.测试上线：在开发完成后，需要进行功能测试、性能测试、安全测试等各种测试，确保功能的稳定性、安全性和性能优化。在测试通过后，可以进行部署上线，将功能交付给用户使用。在上线后，需要进行后续的监控和优化，确保功能的稳定性和用户满意度。\n总之，开发一个新的业务功能需要有明确的需求分析、合理的技术选型、良好的设计实现、严谨的测试上线和后续的监控和优化。在执行过程中，需要遵循良好的开发流程和方法，积极沟通和协作，不断优化和改进过程，确保最终的功能实现符合用户的需求和期望，提高用户的满意度和体验。\n软件开发者从长期来看应该持续学习和发展的技能是什么？作为一名软件开发者，从长期来看应该持续学习和发展的技能主要包括以下几个方面：\n\n编程语言和框架：不同的编程语言和框架在不同的领域中有其优缺点，持续学习和掌握新的编程语言和框架可以扩展你的技能范围，并且在面对新的项目和技术挑战时能更加游刃有余。\n\n架构设计和系统设计：架构设计和系统设计是软件开发的核心，能够清晰地把系统的需求和功能分解为模块，并将它们组织起来，可以使软件更加可靠、可扩展和易于维护。因此，持续学习架构设计和系统设计方面的知识是很重要的。\n\n软件开发方法论和流程：学习并运用成熟的软件开发方法论和流程，如敏捷开发、测试驱动开发（TDD）、持续集成、持续交付等，可以提高团队开发效率和软件质量，从而为软件开发提供更为科学的基础。\n\n数据库技术和数据结构算法：对于需要处理大量数据的系统，学习数据库技术和数据结构算法能够更好地解决数据存储和处理方面的问题。\n\n沟通和团队合作：对于软件开发者来说，良好的沟通和团队合作能力是非常重要的。学习如何与其他团队成员和客户进行有效的沟通和协作，能够帮助你更好地完成团队中的任务，以及在工作中获得更好的结果。\n\n\n总的来说，软件开发是一个快速发展的领域，持续学习和发展是非常重要的，需要不断探索和学习新技术和新的工作流程，以保持自己的竞争力。\nI am a junior developer, who is just graduate from university. I would like you to be a senior Java developer, and you are my mentor, what would you recommend me to do everyday to improve my software development skills efficiently?\nPractice coding: The more you code, the more you will improve. Make sure to spend time every day working on coding exercises, projects, or contributing to open source projects to practice and improve your coding skills.\n\nLearn from others: Seek out feedback and advice from more experienced developers. Attend meetups, join online communities, and reach out to senior developers in your workplace to learn from them and get feedback on your work.\n\nRead and watch: Stay up to date with new trends, technologies, and best practices by reading blogs, articles, and books. Watch videos and attend webinars on relevant topics.\n\nRefactor code: Refactor code regularly to improve its readability, maintainability, and performance. This will help you develop a better understanding of code design and architecture.\n\nCollaborate: Work collaboratively with other developers on projects or code reviews. This will help you learn from others and develop your communication skills, which are critical in software development.\n\nTest code: Write unit tests and integration tests to ensure the code you write is correct and robust. This will help you learn how to write high-quality code that can be easily tested and maintained.\n\nSet goals: Set realistic goals for yourself, both short-term and long-term, and work towards them every day. This will help you stay motivated and focused on improving your skills.\n\n\n","tags":["职业发展"]},{"title":"MybatisPlus","url":"/2023/01/12/MybatisPlus/","content":"为什么mybatisplus 为mybatis只做增强，不做改变，简化开发。只需要少量的配置即可实现单表大部分的CURD操作。\n核心模块boot-starter 启动器annotation 注解core 核心extensiongenerator 生成器\n","tags":["数据库","项目开发"]},{"title":"H2数据库","url":"/2023/01/12/H2%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"为什么用本身是一个类库，可以直接嵌入到项目中。可以和应用程序打包一起发布，方便存储少量结构化数据。只有一个Jar文件，适合作为嵌入式数据库使用。功能完整，支持标准SQL和JDBC。\n","tags":["数据库"]},{"title":"SpringBoot参数校验","url":"/2023/01/13/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/","content":"为什么接口的查询参数后台需要进行校验，同时还需要给出校验的返回信息放到统一封装的结构中。\n如果在controller中直接校验需要用大量的if else做判断。Java API规范（JSR303）定义了Bean的校验标准validation-api。 hibernate validation是对这个规范的实现。增加了注解@Email、@length等。 Spring Validation是对hibernate validation的二次封装，用于支持Spring MVC参数自动校验。\n","tags":["项目开发"]},{"title":"SpringBoot常用注解","url":"/2023/01/13/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","content":"@RestController组合@Controller 和@ResponseBody，用于和一个页面交互数据的控制。\n@RequestMapping(“&#x2F;api&#x2F;copper”)用来映射web请求（访问路径和参数）、处理类和方法。可以注解在类和方法上，注解在方法上的路径会继承注解在类上的路径。\n@RequestParam获取request请求的参数值\n@Bean定义在方法上，在容器内初始化一个bean实例类。\n@Component泛指组件，当组件不好归类的时候，用这个注解。\n@PathVariable用来获取请求url中的动态参数\n@Autowired在默认请求下，@autowired注释进行自动注入时，Spring容器中匹配的候选Bean数目必须有且只有一个。当找不到一个匹配的Bean时，Spring容器将抛出BeanCreationException异常，并指出必须至少拥有一个匹配的Bean。不确定Spring容器中一定有某个类的Bean，使用@autowired（required &#x3D; false），这样找不到匹配的Bean也不会报错。\n@Configuration表示这是一个配置信息类。\n","tags":["项目开发"]},{"title":"SpringBoot统一异常处理","url":"/2023/01/13/SpringBoot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"为什么如果不统一处理异常，那么controller层每个接口会有大量异常处理的代码。\n方案通过@controllerAdvice异常统一处理，这样controller中接口就无需处理异常。\n","tags":["项目开发","SpringBoot"]},{"title":"SpringBoot统一接口封装","url":"/2023/01/13/SpringBoot%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/","content":"为什么统一返回方便前端进行开发和封装，数据+响应编码+信息。\n状态码封装包含responseCode 和 description。\n返回内容封装公共接口返回时间、状态status、消息message、数据data\n接口返回时调用接口返回时，调用内容封装\n","tags":["SpringBoot"]},{"title":"日志框架","url":"/2023/01/12/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/","content":"logbackSpringBoot项目的日志标配\n","tags":["项目开发"]},{"title":"Why English","url":"/2023/01/14/Why-English/","content":"\nFirstly i will record totally in English.\nEnglish learning is a life long journey.\nEnglish is my second language.\nI want to work for a international company.\nKeep writing.\n\n","tags":["English"]},{"title":"我的书单","url":"/2023/01/14/%E6%88%91%E7%9A%84%E4%B9%A6%E5%8D%95/","content":"Spring开发《Spring 技术内幕》《深入实践SpringBoot》《SpringCloud微服务框架开发实战》《SpringBoot实战派》\n提升《程序员修炼之道：从小工到专家》《代码大全》《黑客与画家》\n数据库《MySQL技术内幕：SQL编程》《深入浅出MySQL：数据库开发、优化与管理维护（第2版）》《MySQL必知必会》《Redis设计与实现》\nJava《Java编程的逻辑》《Java编程思想（第4版）》《Java高并发核心编程（卷2）：多线程、锁、JMM、JUC、高并发设计模式》《实战Java高并发程序设计（第2版）》《NIO与Socket编程技术指南》\n计算机基础《程序是怎么跑起来的》《图解HTTP》《网络是怎样连接的》《编码：隐匿在计算机软硬件背后的语言》《UNIX编程艺术》《30天自制操作系统》\n","tags":["我","阅读"]},{"title":"技术阅读","url":"/2023/01/14/%E6%8A%80%E6%9C%AF%E9%98%85%E8%AF%BB/","content":"为什么之前了解到开发项目中，一般更多的不熟悉就看视频，熟悉的看文档，更熟悉的看源码。不看书是因为一般出书的周期比较长，所以看到书的时候，书里的技术都没有那么新了，容易跟不上时代。\n但是今天回过头来看，很多书写的内容是很经典的。他的内容往往体现出深邃的思想，对技术的理解。这些东西不容易从文档或博客中获得。需要一定的沉淀。而广泛流传的经典书籍都总结的很精华的思想，往往在第一遍不能理解透彻，需要多读，实践，之后再度，才能理解其奥妙。\n大学计网老师说你们想学好这门技术，就读10遍书。我觉得这不是确定的数字，但是可以明确知道，要掌握好，理解透彻这门技术，需要不断的研读经典著作，学习领域最顶尖人才的思想，自己也要勤于动手实践和总结。\n所以得出，keep reading。 虽然现在开发技术比较菜，通常跟着视频学习能够学到更多的东西，但是也不能忘记仰望星空。去看看领域最顶尖的人，他最什么事情，他的思想，他的实践方式，从而不再迷茫。\n鼓励自己，talent without working is nothing. 看看这个星球上最好的运动员，他们天赋异禀，但是同时很少有人能像他们一样刻苦的训练。\n","tags":["阅读"]},{"title":"Tomcat","url":"/2023/01/14/Tomcat/","content":"如何设计一个web容器思路比具体实现更重要。 学习把重点放在顶层设计。学习一项技术，需要了解其完整的体系。看完一本书或者一个教程，获取完整的基础知识。\nweb容器提供两种服务，\n\n静态资源的访问 （三个组件，request、HttpServer、Response）直接通过访问根路径 + 静态资源名称访问\nservlet的访问在访问根路径上加上servlet路径来做区分，将这类的请求委托给ServletProcessor来处理。\n\nServlet为了java实现动态可交互网页，web编程的一套标准。\n核心功能：\n\n创建并填充Request对象，URI、参数、Method、请求头Header,请求体body等信息\n创建response对象\n执行业务逻辑，将结果通过Response的输出流传到客户端。\n\nServlet没有main方法，所以执行需要一个容器，容器为了支持Servlet的功能而存在。 Tomcat就是一个Servlet容器的实现。\nTomcat整体架构组件角度：\n\nServer：服务器，启动和停止系统。一切包含在Server中。\nService：服务，Server可以运行多个服务。\nContainer: 容器，servlet容器。 engine（引擎）、host（主机）、context（上下文）、wraper（包装器）都继承自Container接口，所以它们都是容器。\nConnecter：连接器，service和container连接起来。把客户端的请求转发到Container（容器）。\n\n一次完整的请求角度客户端的请求http://localhost:8080/test/index.jsp，\n\n发送到本地端口，被侦听的Connector获取，然后 \nConnector将请求交给它所在的Service的engine来处理，等待Engine来回应；\nengine获取请求，匹配到所有虚拟主机Host，交给host匹配到路径为&#x2F;Test的Context去处理，\nPath&#x3D;&#x2F;test的Context获取请求index.jsp，Mapping table中对应寻找servlet。\nContext匹配到对应的JspServlet,构造HttpServletRequest和HttpServletResponse对象，作为参数调用JspServlet的doGet和doPost方法。\nContext将执行完的HttpServletResponse返回给host\nhost将HttpServletResponse对象返回给Engine\nEngine将HttpServletResponse对象返回给Connector\nConnector把HttpServletResponse对象返回给客户browser\n\n","tags":["中间件"]},{"title":"项目开发idea","url":"/2023/01/14/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91idea/","content":"clone the famous appthe software that i want to use\n读书（记录阅读记录）\ntodolist（记录要做的事情）\n旅行记（记录旅行中的事情）\n技术学习软件（想玩游戏一样学习技术，可以选择学习路线，做完一个任务获取经验，不断升级，初学者可以对技术学习有一个完整的认知，有基础的可以更深入的理解技术，提升能力）。\n技术学习平台（可以提供学习辅导，可以获得学习帮助，获取学习资源、自发的用户，免费的平台。）\n外语学习软件（根据自己目前的需求有选择的学习，学习最直接能得到帮助的内容。）\n定时任务（每日签到，消息推送-没完成的todolist等，提前通知自己在日历中的计划）\n微服务将以前做过的项目统一管理，统一网关、系统监控、统一配置。\n饮食健康APP，记录自己的饮食，有一个健康饮食图谱或者计划，计划中有一定的数据，每天记录自己的饮食，app会对自己的饮食分析对比图谱，对结果会进行反馈，定时任务完成饮食反馈，并且给出饮食计划和改善方案。\n算法面试预约App，用户可以选择成为面试官或者面试人来参与一场面试。通过参与面试来让自己熟悉面试的节奏，查漏补缺，帮助完善自己的算法能力。面试的好处（交流、相互学习、查漏补缺）\n\nsolve the real world problem\n生产消费者问题（利用队列）\n自制操作系统\n自制虚拟机\n路由器\n\n","tags":["软件开发"]},{"title":"Redis","url":"/2023/01/15/Redis/","content":"为什么高并发系统，不可或缺的是缓存。目前使用广泛、高效的一款开源缓存。\n应用场景\n缓存（数据查询、短连接、新闻内容、商品内容等）\n分布式会话（session）\n列表\n任务队列（秒杀、抢购、12306等）\n排行榜\n访问统计\n数据过期处理（精确到毫秒）\n\n基础与数据类型所有key都是String（字符串）。数据类型是说存储值的类型。\n\nString （可以是字符串、整数或浮点数）\nList（链表，每一个链表都包含一个字符串）\nSet（字符串的无序集合）\nZset（对字符串成员和浮点数分数之间有序映射。排序顺序通过分数大小决定。）\nHash（键值对的无序散列表）\n\n核心概念\n数据结构：Redis支持多种类型的数据结构，如字符串，哈希，列表，集合，有序集合等；\n持久化：Redis支持将数据定期以持久化的方式写入磁盘，以防止系统宕机时的数据丢失；\n集群：Redis支持将数据分布在多个节点上，以提供高可用性和可伸缩性；\n事务：Redis支持将多个命令组合为一个事务，以提供原子性操作；\n过期：Redis支持设置数据过期时间，超过指定时间后数据会自动被清除；\n脚本：Redis支持Lua脚本，以提供复杂的原子操作；\n发布&#x2F;订阅：Redis支持。\n\n核心模块&#x2F;组件Redis核心模块包括客户端、数据库、网络模块、内存和存储模块、持久化模块以及其他管理模块。Redis核心组件包括：Redis服务器、Redis客户端、Redis内存数据库、Redis协议、Redis编程库和Redis命令行客户端。\n工作原理Redis是一种开源的内存数据库，它通过将数据存储在内存中而提供高性能。它使用简单的键&#x2F;值存储模型，允许用户在内存中存储和检索任意类型的数据。Redis还提供一系列强大的功能，包括事务处理，发布&#x2F;订阅，和自动持久化，使其成为一种特别适合建立实时应用程序的理想数据库。\n","tags":["中间件"]},{"title":"Zookeeper","url":"/2023/01/15/Zookeeper/","content":"为什么作为大型分布式系统的可靠协调系统，zookeeper提供分布式系统底层且必不可少的基本功能。开发者可以轻松在Zookeeper之上构建自己的各种分布式系统。 \n核心优势： 实现了分布式环境的数据一致性，访问Zookeeper的树结构时，不同的节点返回的数据都是一致的。 对Zookeeper进行数据访问时，不会引起脏读、重复读。\n同时在实际生产环境中应用非常广泛、例如SOA的服务监控系统、Hadoop、Spark的分布式协调系统。\n基本功能配置维护、名字服务、分布式同步、组服务。\n","tags":["分布式"]},{"title":"JPA","url":"/2023/01/17/JPA/","content":""},{"title":"Session在开发中的使用","url":"/2023/01/15/Session%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"单机sessionHttpSession是通过Servlet容器进行创建和管理的，\n","tags":["项目开发"]},{"title":"接口文档技术","url":"/2023/01/17/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E6%8A%80%E6%9C%AF/","content":"Swagger用于生成、描述和调用Restful接口的web服务。 将项目中所有接口展现在页面上，并且可以进行调用和测试服务。\n\n将所有接口展现在页面上，后端程序员就不需要专门为前端使用者编写专门的接口文档。\n接口更新后直接修改代码中的Swagger描述就可以生成新文档了。\n通过页面可以直接进行接口调用、降低了开发阶段的调试成本。\n\nSpringFox对应Swagger 就像Spring中的IoC对DI 前者是思想、后者是实现。\nKnife4j为MVC框架集成Swagger生成API文档的增强解决方案。\n\n专注于前后端代码分离、微服务架构下使用灵活。\n提供Swagger的增强解决方案，不同于之改善前端UI的部分。\n\nSmart-DocSwagger在生成api文档需要在接口上添加注解等，这是一种侵入的方式。smart-doc是一种非侵入的方式多数情况多数人会选择Swagger + openapi技术栈。\n","tags":["项目开发"]},{"title":"集中式与分布式系统区别与选择","url":"/2022/11/27/%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%80%89%E6%8B%A9/","content":"集中式系统特点一个主机带多个终端。终端不具备数据处理能力，仅负责数据的录入和输出。而运算、存储等全部在主机上进行。\n集中式系统利弊优点：\n\n架构简单，通用和应用耦合度低，资源调度灵活.\n数据集中存储和处理，所以系统响应快，数据可靠性高，一致性好。\n稳健、可靠、易维护管理的特点。\n\n缺点：\n\n单机不可用会造成全局不可用。\n单点故障（单个点发生故障时，会波及到整个系统或者网络，从而导致整个系统或网络的瘫痪）\n扩展性差\n\n分布式系统特点分布式系统 高内聚和透明性。\n\n内聚性 ：每一个数据库分布节点高度自治，由本地的数据库管理系统。\n透明性：每一个数据库分布节点对用户的应用来说都是透明的，看不出是本地还是远程。\n\n分布式系统利弊灵活，性价比高，同时安全自主，弹性伸缩能力优势明显。\n分布式系统去中心化，通过主备，冗余、哈希等实现了计算与存储的高可用性。\n","tags":["分布式"]},{"title":"文件上传下载","url":"/2023/01/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/","content":"需求功能需要将数据文件上传到服务端，或者将服务端的数据以某种文件形式下载到客户端。\n实现Spring Boo文件上传与下载。https://www.jianshu.com/p/95469ecfbb62\n","tags":["项目开发"]},{"title":"定时任务","url":"/2023/01/17/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","content":"应用场景每天&#x2F;月&#x2F;周生成日志汇总、定时消息推送、定时生成数据表格等\n实现\nJDK内置\nTimer\nScheduleExecutorService\n\n\nNetty\nHashedWheelTimer\n\n\nSpring\nSchedule\nQuartz\n\n\n分布式集群\nQuartz持久化JDBC方式\nElastic-job\nxxl-job\n\n\n\n","tags":["项目开发"]},{"title":"Spring核心","url":"/2023/01/19/Spring%E6%A0%B8%E5%BF%83/","content":"特性\n非侵入\n控制反转\n依赖注入\n容器\n组件化\n一站式\n\n核心概念控制反转（IoC）、面向切面编程（Aop）依赖注入（DI）\n核心模块开发过程中可以根据需求有选择性地使用所需要的模块。\n\nCore Container （核心容器：构建其他模块建立的基础，组成：Beans、Core、Context、SpEL）Bean模块： 提供框架的基础部分，包括控制反转和依赖注入。Core核心模块： 封装了Spring的底层部分，包括资源访问、类型转换及一些常用工具类。\nData Access&#x2F;Integration（数据访问&#x2F;集成）JDBC 模块： JDBC的样例模板ORM 模块OXM 模块JMS 模块Transaction 事务模块：支持编程和声明式事务管理。\nWeb （网络）Web 模块：提供了基本的Web开发集成特性Servlet 模块：提供了一个Spring MVC Web框架实现。WebSocket 模块Webflux 模块\nAOP、Aspects、Instrumentation和MessagingCore container之上的是Aop、Aspects等模块。Aop 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，而且动态把这些功能添加到需要的代码中， 各司其职，降低业务逻辑和通用功能的耦合。Aspects 模块： 提供了AspectJ的集成，是一个强大功能且成熟的面向切面（AOP）框架。Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。messaging 模块：对消息传递体系结构和协议的支持。jcl 模块：对日志框架集成的模块。\nTest 模块Spring 支持Junit和TestNG 测试框架，而且额外提供了Spring的测试功能，比如Web框架测试，模拟Http请求的功能。包含 Mock Objects， TestContext Framework， Spring MVC Test, WebTestClient。\n\nSpring核心组件Spring的核心组件有五个： \n\nSpring IOC：控制反转（IoC）和依赖注入（DI）框架。 \n\nSpring AOP：面向切面编程（AOP）框架。 \n\nSpring DAO：数据访问对象（DAO）框架。\n\nSpring Context：应用上下文框架。\n\nSpring MVC：模型视图控制器（MVC）框架。\n\nIOC容器：IoC容器是Spring的核心，它管理着整个Spring框架的组件。通过IoC容器可以将项目中的对象解耦，实现面向切面编程（AOP），它可以在不改变代码的情况下，对程序进行非常精细的控制。\n\nAOP：AOP是Spring的另一个核心组件，它是用于实现切面编程（AOP）的基础技术。AOP可以将非核心业务逻辑从业务逻辑中分离出来，并进行封装，从而有效地减少代码的冗余，提高代码的可重用性，并有助于系统的维护和更新。 \n\nSpring MVC：Spring MVC是Spring框架的另一个核心组件，它是基于Java EE的MVC模式的Web框架，它可以将Web请求映射到控制器。\n\n\nSpring工作原理Spring工作原理是通过IOC容器来完成的，IOC容器用Java语言的反射机制来创建一个实例，然后通过DI来连接组件，使得容器中的每一个组件都可以与其他组件交互。同时，容器中的每一个组件都可以通过配置文件来设置属性，从而实现松耦合的效果。\n","tags":["Spring"]},{"title":"项目开发规范","url":"/2023/01/19/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","content":"测试单元测试、集成测试\n","tags":["项目开发"]},{"title":"消息队列","url":"/2023/01/20/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","content":"应用场景\n高并发场景：当服务器面对大量并发请求时，消息队列可以帮助把请求暂时缓存起来，等服务器处理完当前的任务后再从消息队列中获取之前缓存的请求。 \n异步处理：通过消息队列，可以把耗时的操作放到消息队列中，让它异步执行，提高系统的效率。 \n数据聚合：当各个服务器上都有一份相同的数据时，可以通过消息队列来聚合各个服务器上的数据，从而实现数据的共享和交互。 \n日志处理：把日志放入消息队列，可以让日志处理程序异步的处理这些日志，这样可以减少日志处理的延迟。 \n分布式计算\n\n业务场景1、分布式系统：分布式系统中，消息队列可以用来解耦服务之间的数据传输，实现服务间的解耦，保证每个服务只关注自己的业务逻辑，提高系统的可用性和容错性。2、移动端应用：移动端应用如果有大量数据需要实时传输，就需要使用消息队列来实现数据的实时传输和实时处理。3、互联网金融：互联网金融中，消息队列可以帮助用户实现资金的实时传输和实时处理，保证交易的安全性和可靠性。4、物流系统：物流系统中，消息队列可以用来实现物流状态的实时传输和实时处理，以实现物流信息的有效\n","tags":["项目开发"]},{"title":"JUnit5","url":"/2023/01/20/JUnit5/","content":"核心概念核心模块","tags":["项目开发"]},{"title":"Chinese lunar new Year","url":"/2023/01/27/Chinese-lunar-new-Year/","content":"what i learnedChinese lunar new year is the real beginning of a year for Chinese people.\n\n农历中国年才是中国真正一年的开始。\n\n","tags":["English"]},{"title":"Java之IO","url":"/2023/01/21/Java%E4%B9%8BIO/","content":"常见类\n磁盘操作：File\n字节操作：InputStream和OutputStream\n字符操作：Reader和Writer\n对象操作：Serializable\n网络操作：Socket\n\nBIONIOAIO","tags":["Java"]},{"title":"what is object oriented programming?","url":"/2023/01/23/what-is-object-oriented-programming/","content":"main conceptsoops is about inheritance, abstraction, ploy\n","tags":["English"]},{"title":"项目开发技术资源","url":"/2023/01/21/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E8%B5%84%E6%BA%90/","content":"SpringSecurity O_auth 2  JWT (授权、SSO)https://gitee.com/hhgs_admin/springsecurityoauth2-demo?_from=gitee_search\n前端资源\nMDN\n\n后端资源\nMDN\n\n综合\nMDN\n菜鸟教程\n\n","tags":["项目开发"]},{"title":"最近在做什么002","url":"/2023/01/29/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88002/","content":"在做什么\n学习Spring中用到的设计模式思想、demo和应用场景\n复习算法和数据结构\n\nwhy前一段时间一直在研究做项目，感觉重复很多CURD就是不断的积累一些小的设计思路和技巧，需要精进自己的设计思想和算法与数据结构的使用。所以这段时间开始加强这方面。\n感想与收获\n一个很好的学习新语言基础语法的方式就是用这个语言来刷题。\n\n","tags":["最近在做什么"]},{"title":"MergeSort","url":"/2023/01/30/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"WHY排序算法为基础可以是的解决其他复杂问题变得简单。归并排序算法可以用来排序数字、排序字符串、排序链表\n建立在归并操作上的排序算法，采用了分治法，将问题划分为小的问题，分而治之。\n实现两种实现方式：\n\n自上而下的递归（递归都可以用迭代来做）\n\n自下而上的迭代各种形式：\n\n原地归并排序\n\n自然分组归并排序\n\n常规归并排序\n\n\n复杂度性能不受输入数据的影响，时间复杂度始终是O(NLogN).\n","tags":["English","算法"]},{"title":"git使用问题","url":"/2023/01/31/git%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/","content":"替换现在远程仓库中的文件夹A，里面有子文件夹B、C、D我只想留下B这个子文件夹，其他删掉，但是本地文件我不想动，如何做？\n","tags":["git"]},{"title":"HeapSort","url":"/2023/01/31/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"whatsorting using the features of MaxHeap or MinHeap(from which you can get the max or min value from the root node of the heap)\n排序过程process of the sorting\n首先构建最大（小）堆，\n堆首和堆尾互换\n堆的尺寸缩小1， 调到用shift_down(0), 把新的数组顶端数据调整到响应的位置。\n重复2，直到堆尺寸为1./**     * 堆排序，先构造一个大顶堆或者小顶堆，利用构造堆，每次找到当前子数组中最大或者最小的值，完成排序     *     * */    public int[] sort(int[] sourceArray) &#123;        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int len = arr.length;        buildMaxHeap(arr, len);        System.out.println(Arrays.toString(arr));        for (int i = len - 1; i &gt; 0; i--) &#123;            swap(arr, 0, i);            len--;//            System.out.println(Arrays.toString(arr));            heapify(arr, 0, len);        &#125;        return arr;    &#125;\n\n构建堆原理与方法利用堆的特性，数组中元素下标i，可以找到它的左右子节点的下标为i * 2 + 1 和 i * 2 + 2。从数组的中间索引开始，递减的顺序，计算找到左右子节点的位置，然后对比节点大小，转换成符合条件的状态（大顶堆，就让左右节点中最大的值替换为当前节点，小顶堆相反）。如果发生了替换，就递归向下将替换下去的这个节点再对比左右节点做这个堆化的操作。 因为这个堆化的过程顺序是从初始数组的中间索引开始的，也就是其左右子树已经是最底层的叶子节点。所以按照这个顺序来堆化，就保证了整棵树可以完全的堆化成符合条件（大顶堆，左右子节点小于当前节点，小顶堆相反）的样子。\n/**     * 方法名： 构建最大堆     * 功能： 从中间节点开始扫描，这样就可以保证数组中所有的元素都参与判断了一遍，而且是从堆的最底部开始判断     * */private void buildMaxHeap(int[] arr, int len) &#123;        for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123;            heapify(arr, i, len);        &#125;&#125;/**     *  方法名： 堆化     *  功能： 将当前节点作为根节点进行堆化，不断的递归进行， 将当前     * */private void heapify(int[] arr, int i, int len) &#123;//        System.out.println(Arrays.toString(arr) + &quot; 进入堆化&quot; );//      寻找当前节点的左右子节点，因为是最大堆，所以要让当前节点i的值最大        int left = 2 * i + 1;        int right = 2 * i + 2;        int largest = i;//        System.out.println(&quot;当前节点为 &quot; + arr[i]);//        if (left &lt; arr.length &amp;&amp; right &lt; arr.length) &#123;//            System.out.println(&quot;当前节点左节点为 &quot; + arr[left]);//            System.out.println(&quot;当前节点右节点为 &quot; + arr[right]);//        &#125;//        判断如果左右节点如果比当前节点值大，就交换        if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;            largest = left;        &#125;        if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;            largest = right;        &#125;//       如果发生了交换，那么将该节点的交换过的这个节点在进行堆化，递归的进行下去        if (largest != i) &#123;//            if (largest == left) &#123;//                System.out.println(Arrays.toString(arr) + &quot; 交换了左节点&quot;);//            &#125; else &#123;//                System.out.println(Arrays.toString(arr) + &quot; 交换了右节点&quot;);//            &#125;            swap(arr, i, largest);            heapify(arr, largest, len);        &#125;//        System.out.println(Arrays.toString(arr) + &quot; 完成堆化&quot;);    &#125;","tags":["English","算法"]},{"title":"面试准备","url":"/2023/01/31/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","content":"算法和数据结构leetcode-master\n通过刷题来熟练掌握 基础数据结构与算法、java集合与并发通过项目熟练网络协议（TCP&#x2F;HTTP）、JVM、Linux部署（操作系统）、Docker、数据库，Spring框架（特性：IOC、AOP、启动原理、自动配置原理、Bean生命周期）\n设计模式、写demo—-学习分析Spring中用到的设计模式（单例、工厂、代理）https://www.pdai.tech/md/dev-spec/pattern/4_factory_method.html\nJava核心 八股（面向对象、容器、并发、JVM）https://github.com/dunwu/javacore\n"},{"title":"各种驱动开发","url":"/2023/02/01/%E5%90%84%E7%A7%8D%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","content":"领域驱动开发DDD测试驱动开发TDD","tags":["项目开发"]},{"title":"我正在做的项目","url":"/2023/02/01/%E6%88%91%E6%AD%A3%E5%9C%A8%E5%81%9A%E7%9A%84%E9%A1%B9%E7%9B%AE/","content":"构建微服务集群一直有很多小的项目想法，但是很单一，这些项目很分散。于是想到微服务的方式，将这些项目做成一个微服务集群，通过微服务统一网关来访问。Docker容器化部署。这样也方便收集我的作品集合。\n做什么现在要做的就是将以前的项目集合整理起来，统一网关。系统监控、数据库配置，注册中心。单点登录。\n系统有什么子系统：\n\n读书系统\n旅行系统\ntodoList\n项目管理系统\n外语学习平台\n物品订购系统\n\n","tags":["项目开发"]},{"title":"设计模式之单例","url":"/2023/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B/","content":"singleton\n思想确保一个类只有一个实例，并提供该实例的全局访问点\n使用一个私有构造函数、一个私有静态变量、一个公有的静态函数来实现。这样只能通过这个公有的静态函数来返回唯一的私有静态变量。\n实现方式\n懒汉式-线程不安全\n\n私有静态变量uniqueInstance在使用的时候，被实例化\npublic class Singleton &#123;    private static Singleton uniqueInstance;        private Singleton() &#123;    &#125;         public static Singleton getUniqueInstance() &#123;        if (uniqueInstance == null) &#123;            uniqueInstance = new Singleton();        &#125;        return uniqueInstance;    &#125;&#125;\n这种实现方式在多线程的环境下会存在多个线程同时进入if语句，创建多个实例。\n\n饿汉式-线程安全\n\n在类加载时，直接赋值创建实例，这样保证不会重复创建实例。\nprivate static Singleton uniqueInstance = new Singleton();\n\n\n懒汉式-同步机制\n\n通过给静态函数加锁，一个线程创建时，其他线程只能等待，保证了线程安全。但是锁粒度比较大，开销大。\npublic class Singleton &#123;    private static Singleton uniqueInstance;        private Singleton() &#123;    &#125;         public static synchronized Singleton getUniqueInstance() &#123;        if (uniqueInstance == null) &#123;            uniqueInstance = new Singleton();        &#125;        return uniqueInstance;    &#125;&#125;\n\n懒汉式-双重检测将锁的粒度减小，只需要给实例化的部分加锁，首先判断是否已经生成实例，如果没有生成实例的时候才给实例化部分加锁。public class Singleton &#123;    private volatile static Singleton uniqueInstance;        private Singleton() &#123;    &#125;         public static Singleton getUniqueInstance() &#123;        if (uniqueInstance == null) &#123;            synchronized (Singleton.class) &#123;                if (uniqueInstance == null) &#123;                    uniqueInstance = new Singleton();                &#125;            &#125;        &#125;        return uniqueInstance;    &#125;&#125;\n如果是这样，在没有实例化的时候，两个线程进入了if语句，所以加了同步控制，但是只是先后的顺序去实例化，会产生多实例。所以需要双重检测，同步的情况下，第一个线程实例化之后，第二个语句进入同步块时，判断if的条件就不成立，也就控制了单实例。if (uniqueInstance == null) &#123;    synchronized (Singleton.class) &#123;        uniqueInstance = new Singleton();    &#125;&#125;\n\nvolatile 关键字修饰uniqueInstance， 因为uniqueInstance &#x3D; new Singleton();语句分三步执行：（1） 开辟存储空间（2） 初始化对象（3） 让uniqueInstance实例指向空间。   JVM具有指令重排的特性，可能执行顺序会编程1-3-2，多线程的情况下可能产生没有初始化的实例。volatile可以禁止指令重排，在多线程下正常运行。\n\n静态内部类public class Singleton &#123;        private Singleton() &#123;    &#125;         private static class SingletonHolder &#123;       private static Singleton INSTANCE = new Singleton();    &#125;        public static Singleton getUniqueInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;\n枚举实现实现简单，在序列化和反射攻击时，可以防止多实例。public enum Singleton &#123;    uniqueInstance;&#125;\n\n","tags":["设计模式"]},{"title":"常用软件和平台","url":"/2023/02/02/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%92%8C%E5%B9%B3%E5%8F%B0/","content":"收藏夹云收藏-github开源\n我的博客github托管 github.io\nleetcode","tags":["我"]},{"title":"QuickSort","url":"/2023/02/02/QuickSort/","content":"思想找到一个基准，将要排序的数据分成两部分， 一部分比另一部分所有元素都小。 然后按照这个方式递归的对这两部分数据进行快速排序。\n排序过程\n从数列中找一个基准\n从右往左找到小于基准的值，替换掉i（对应的值），从左往右找到大于基准的值，替换掉j，重复，直到 i &gt;&#x3D; j，用基准替换这个i；这个过程完成之后，基准位于中间位置。\n递归的把基准前后的子序列进行排序。\n\n实现public void quickSort(int[] a, int l, int r) &#123;\tif (l &lt; r) &#123;\t\tint i, j, x;\t\ti = l;\t\tj = r;\t\tx = a[i];\t\t\t\twhile (i &lt; j) &#123;\t\t// 从右往左找到不大于x的\t\t\twhile (i &lt; j &amp;&amp; a[j] &gt; x) \t\t\t\tj--;\t\t\tif (i &lt; j) &#123;\t\t\t\ta[i++] = a[j];\t\t\t&#125;\t\t// 从左往右找到不小于x的\t\t\twhile (i &lt; j &amp;&amp; a[i] &lt; x)\t\t\t\ti++;\t\t\tif (i &lt; j) &#123;\t\t\t\ta[j--] = a[i];\t\t\t&#125;\t\t&#125;\t\ta[i] = x;\t\tquickSort(a, l, i - 1); //递归排序基准左边\t\tquickSort(a, i + 1, r); //递归排序基准右边\t&#125;&#125;","tags":["English","算法"]},{"title":"设计模式之工厂","url":"/2023/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82/","content":"简单工厂简单工厂类就是生产对象的类。利用工厂生产对象，类实例化和对象的操作分离开。使用者不需要直到具体参数就可以实例化出对应的产品，避免客户端中显示指定，实现了解耦。\n\n组成\n\n抽象产品\n具体产品\n工厂\n\n工厂方法定义了创建对象的接口，但由子类决定实例化哪个类，将实例化操作推迟到子类。\n抽象工厂创建的是对象家族，而不是单个对象，这些对象是相关的，必须一起创建出来。\n抽象工厂使用了组合，组合了AbstractFactory，而工厂方法模式使用了继承。\n","tags":["设计模式"]},{"title":"学习方法","url":"/2023/02/02/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/","content":"由来 story最开始学习今天学这个，明天学那个，逐渐的我开始想到要定下来一个方向。从现在开始我就只关注这个事情。 解决了每天没有固定的目标的问题。  \n有了固定目标，我开始坚持做一件事情，一天一天的坚持下去了，但是好像走上了一条看不到终点的路。这种坚持会比较累，逐渐每天一个小小的成就感没有诱惑力了。也就逐渐放弃坚持了。\n我发现了终点线 deadline这种方法，有了目标之后，再给自己设置一个deadline，这样我就可以每天获得小的成就感，而且知道坚持这一天就离完成目标更近一步，也更好坚持完成目标。但是出现了新问题。 每天的任务量可能做不完，会觉得累，然后就停下了。\n将每天的任务再划分，并且规定上午就在这个时间点去做这项任务。 这样就不会觉得当天的任务有多繁重了，因为有了小的deadline。\n终点线 deadline学习一件事情，一个技能要设置终点时间。在学校读书很多年，学会很多东西，技能，在期末考试的时候基本都差不多了。不管考了多少分，掌握到了什么程度，在这个时间点就结束了。当然之后还可以继续学，但是明确了终点时间，在初始学习的过程中就有了目标感，有了紧迫感，有了进度感知。\n目标感有了目标，就不容易迷失方向。\n成就感完成一件小的事情，就能获得成就感。将一个大的目标划分，规划为小的任务。坚持不断的完成小事情，这是很容易获得的成就感。成就感会产生持续的动力。 不断积累小的成就感，终点会获得大的进步。\n如何构建学习的闭环需求 -\n\n要素\n\n\n投入时间 \n输入资料\n练习（巩固和纠错）\n总结（加强认知）\n\nlife long learner坚持学习是因为感兴趣，或者有需要。\n","tags":["技巧","English"]},{"title":"设计模式之代理","url":"/2023/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86/","content":"代理意图控制对其他对象的访问。\n应用场景\n控制对其他对象的访问\n懒初始化\n实现日志\n统计对象的引用\n\n参考 (https://java-design-patterns.com/patterns/proxy/#explanation)\n (https://www.pdai.tech/md/dev-spec/pattern/14_proxy.html)\n","tags":["设计模式"]},{"title":"good way to learn english","url":"/2023/02/04/good-way-to-learn-english/","content":"learn sth that you are interested in\nhow to be a independent developer\nsoftware development\nalgorithms and data structure\nbasketball\n\nfocus on concepts\nother than memorize vocabulary\ntry to teach others what you learned about the concepts by making videos or writing blogs\n\ntake notes\nwrites down what you learned and keep improving your expression\nwrite down what you don’t know before and what you excited about.\n\nlearn professional skills or concepts in english\nlike what you do\nwhat you want learn\nwhat skill that can transfer your career\n\n","tags":["english"]},{"title":"BucketSort","url":"/2023/02/05/BucketSort/","content":"特征 feature桶排序最好情况下可以在线性时间O(N),桶排序的时间复杂度取决于对各个桶之间数据进行排序的时间复杂度。\n是否稳定稳定的排序算法， 判断就是 a[i] &#x3D; a[j], i &lt; j, 在排序完成之后，i和j下标对应的元素顺序没有改变。\n排序过程\n创建一个容量为待排序数组中最大元素值的数组\n遍历待排序数组，将辅助数组填充， 对应的将待排序元素作为辅助数组的小标，来统计该大小的元素出现的次数\n遍历辅助数组，来修改待排序数组内容，按顺序将辅助数组中的值大于0的元素下标赋值给待排序数组。\n\n代码实现public static void bucketSort(int[] a, int max) &#123;        int[] buckets;        if (a == null || max &lt; 1) &#123;            return;        &#125;//        创建一个容量为max的数组buckets        buckets = new int[max];//        1. 计数        for (int j : a) &#123;            buckets[j]++;        &#125;//        2. 排序        for (int i = 0, j = 0; i &lt; max; i++) &#123;            while ((buckets[i]--) &gt; 0) &#123;                a[j++] = i;            &#125;        &#125;    &#125;","tags":["English","算法"]},{"title":"Interview Preparation","url":"/2023/02/07/Interview-Preparation/","content":"behavioral questions\nWhat is your biggest achievement?\n\n\nmy personal website which is a collection of my information and my projects (my combination of tech skills in practice)throught it can know me more detailed. and i will keep maintaining the site along with my career growth.\n\n\nWhy did you get into technology?\n\ntech change the world, make people become more productive, and i good at math and english, i like making software.\n\nTell one thing interesting about you not in your resume?\n\nI am so curious about the tech field, i’ve learned a few programming languages, js front-end, back-end. And i made a lot of small projects, like todolist, calender, chat-apps and blogs. I write blogs and make opensource projects,I am a active user of GitHub. \n\nDescribe a difficult situation you had to overcome?\n\nI write down what i am going through, and i take analyze every step that i could do to overcome this situation.\n\nWhat do you know about our company?\nfounded in 2010, UK,London.\nOffice in 25 Main cities.\n\nHow do you manage your time?Depends on what i will do in the future, for example, when i plan to get a job, i manage my time to applying jobs, prepare for interviews, optimize my profile and resume.\n\nWhat ignited your interest in tech and why are you excited about pursuing a career in this field?\n\n\nI my school time i expericen the change of computer that people use old computer display, and now people use more light and clear computer, and the software and network become fast and efficient.\nTech change the world, make people become more productive, and i would like to make contribution to this field.\n\nWhat do you do in your spare time which demonstrates your passion for technology?\n\ni am a active user of github, i make opensource projects and i always looking for other people’s blog. I followed a lot of software engineers. I am interested to find out what they did, and what they are doing recently.If there is something cool, i will do it, because i want to expanding my skills.\n\nTell me about a time where you have pushed yourself out of your comfort zone, this can be academic, professional or in your personal life? And what did you learn from this?\n\nThere was a hard time after i graduation, i had no idea on how to find a job, and what should i do, but i was shy to look for others help. But i become so longing for start my career. So i went to text my brother, who is in tech field for three years. And that day we had a long conversation and he let me know, i don’t have to worry so much. What i should do is the make my self so prepare for it to  make sure if a got a chance, i can go all out.\n\nTell me about one of your favorite experiences working with a team, what was your role and what impact did you have on the team?\n\nI would say that’s my first experience with my teammate that i organized to make a software projects. \nI did requirements design, and backend development.I recommanded to use our collaboration tool, which make us work together efficiently even we are not at the same place.\n\nTell me about a time when you had to juggle several projects at the same time, how did you organize your time? What was the result?\n\nWhat is the important of diversity in the workplace?\n\nTell us about a time you managed two projects at the same time. What did you learn from it?\n\n\n","tags":["English"]},{"title":"Node.Js入门到实战","url":"/2023/02/08/nodeJs%E5%85%A5%E9%97%A8/","content":"学习路径\n学习语言基础\n语言特性\nweb框架\n\n目前已完成\n语言基础 和 js相同 完成\n语言特性 基本了解完成\nweb框架- Express 基本了解\n\n正在进行Express web开发实战RestAPI、JXcore打包，集成数据库MySQL和Mongo。\n后续阶段多线程\n资源\n菜鸟教程https://www.runoob.com/nodejs/nodejs-callback.html\n\nexpresshttps://expressjs.com/en/guide/database-integration.html\n\n\nnode应用的组成\n引入required模块：使用require指令来载入Node.js 模块。\n创建服务器：服务器可以监听客户端的请求，类似于HTTP服务器。\n接受请求与响应\n\nNPM 包管理工具nodejs 包下载命令 npm install express -  Node.js 的web框架\nREPL(交互式解释器）类似Windows系统的终端shell，可以接受命令，并响应。可执行任务：\n\n读取\n执行\n打印\n循环\n\n事件循环所有异步I&#x2F;O操作完成时，都会发送一个事件到事件队列。 所有事件的对象都是EventEmitter的实例。EventEmitter 提供了多个属性，on 来绑定事件函数，emit用于触发一个事件。\nBufferJS没有二进制数据类型，node中定义了Buffer类，用来存放二进制数据的缓存区。可以用来处理TCP流和文件流。\nStream模块系统全局对象__filename__dirnamesetTimeout(cb, ms); 多少毫秒之后执行函数clearTimeout(t) t是定时器， 用于停止定时器setInterval(cb, ms)  指定毫秒之后执行指定函数，会不断的执行，知道clearInterval()调用，或者窗口关闭。\n常用工具util是Node.js常用工具，用于弥补js的功能不足。https://www.runoob.com/nodejs/nodejs-util.html\n文件系统node文件系统模块中的方法都有异步和同步版本。类似UNIX标准的文件操作API。\n工具模块\nOS模块 操作系统函数\nPath模块 处理和转换文件路径的工具\nNet模块 底层的网络通信\nDNS模块 用于解析域名\nDomain 模块 简化异步代码的异常处理， 捕捉处理try catch无法捕捉的异常。\n\nWEB 模块web服务器基本功能提供web信息浏览服务。 Node 提供了http模块，用于搭建HTTP服务器和客户端。用来编写服务器和客户端请求。\nExpress 框架强大的特性创建各种web应用，丰富的HTTP工具。使用Express可以快速地搭建一个完整功能的网站。核心：\n\n可以设置中间件来响应HTTP请求。\n定义了路由表用于执行不同的http请求。\n可以通过模板传递参数来动态渲染HTML页面。更多使用细节：https://www.runoob.com/nodejs/nodejs-express-framework.htmlhttps://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs/Introduction\n\n总结在学习了JS基本语法之后，学习Node.js比较丝滑，看完了菜鸟教程的基础教学，蠢蠢欲动，实战一下。感谢菜鸟教程。\nNode应用场景：Node.js is a popular, open-source JavaScript runtime environment that allows developers to build server-side applications using JavaScript. With Node.js, you can:\nBuild web servers: You can build fast and scalable web servers using Node.js and its built-in modules, such as HTTP, to handle HTTP requests and responses.\nCreate real-time applications: Node.js is well-suited for building real-time applications, such as chat applications and online games, due to its fast, non-blocking I&#x2F;O and event-driven architecture.\nBuild command-line tools: Node.js can be used to build command-line tools that automate tasks and perform various operations.\nBuild RESTful APIs: You can use Node.js to build RESTful APIs for your web applications. You can use frameworks like Express.js to simplify the process of building APIs.\nCreate desktop applications: You can use Node.js and desktop application frameworks like Electron to build cross-platform desktop applications.\nAutomate tasks: Node.js can be used to automate various tasks, such as processing files, generating reports, and performing backups.\nBuild IoT applications: Node.js can be used to build Internet of Things (IoT) applications by connecting to sensors and devices and processing the data they generate.\nThese are just a few examples of what you can do with Node.js. The versatility and popularity of the platform have led to a rich ecosystem of libraries and tools, making it possible to build a wide variety of applications.\n","categories":["技术"],"tags":["编程"]},{"title":"职业发展规划与思考","url":"/2023/02/06/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92%E4%B8%8E%E6%80%9D%E8%80%83/","content":"职业发展最重要的能力是什么有规划，有目标，有认知，有行动、共情（empathy）\n如何保持自己的核心竞争力合作能力、思考能力，学习能力，沟通能力，态度，好奇心\n关注行业趋势关注行业领头企业、行业经营模式、工作方式。知道最厉害的人是谁，他们在做什么，如何做。及时调整为迎接变化做好准备。\n学习能力积累组织出来一套自己的学习体系。stay hungry， stay foolish。\n","tags":["职业发展"]},{"title":"设计模式之观察者","url":"/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85/","content":"意图定义对象之间的一对多依赖，一个对象状态改变时，它的所有依赖都收到通知并且自动更新状态。主题（subject）是被观察者对象，所有依赖者（Observer）称为观察者。\n气象站和数据显示器 demopublic interface WeatherSubject &#123;    void registerObserver(WeatherObserver o);    void removeObserver(WeatherObserver o);    void notifyObserver();&#125;public class WeatherData implements WeatherSubject &#123;    private List&lt;WeatherObserver&gt; observers;    private float temperature;    private float humidity;    private float pressure;    public WeatherData() &#123;        observers = new ArrayList&lt;&gt;();    &#125;    public void setMeasurements(float temperature,    float humidity, float pressure) &#123;        this.temperature = temperature;        this.humidity = humidity;        this.pressure = pressure;// 状态更新之后通知所有观察者        notifyObserver();    &#125;    @Override    public void registerObserver(WeatherObserver o) &#123;        observers.add(o);    &#125;    @Override    public void removeObserver(WeatherObserver o) &#123;        int i = observers.indexOf(o);        if (i &gt;= 0) &#123;            observers.remove(i);        &#125;    &#125;    @Override    public void notifyObserver() &#123;    //更新所有观察者状态。        for (WeatherObserver o : observers) &#123;            o.update(temperature, humidity, pressure);        &#125;    &#125;&#125;public interface WeatherObserver &#123;    void update(float temp, float humidity, float pressure);&#125;public class StatisticsDisplay implements WeatherObserver &#123;// 构造函数执行时，将观察者注册到主题中去。    public StatisticsDisplay(WeatherSubject weatherData) &#123;        weatherData.registerObserver(this);    &#125;    @Override    public void update(float temp, float humidity, float pressure) &#123;        System.out.println(&quot;StatisticsDisplay.update &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    &#125;&#125;public class CurrentConditionDisplay implements WeatherObserver &#123;// 构造函数执行时，将观察者注册到主题中去。    public CurrentConditionDisplay(WeatherSubject weatherData) &#123;        weatherData.registerObserver(this);    &#125;    @Override    public void update(float temp, float humidity, float pressure) &#123;        System.out.println(&quot;CurrentConditionDisplay.update &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    &#125;&#125;public class WeatherStation &#123;// 气象站数据发生改变时，显示器收到通知自动更新状态。    public static void main(String[] args) &#123;        WeatherData weatherData = new WeatherData();        CurrentConditionDisplay currentConditionDisplay = new CurrentConditionDisplay(weatherData);        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);        weatherData.setMeasurements(0, 0, 1);        weatherData.setMeasurements(1, 1, 2);    &#125;&#125;\n","tags":["设计模式"]},{"title":"JS训练","url":"/2023/02/12/JS%E8%AE%AD%E7%BB%83/","content":"资源\n菜鸟教程：https://www.runoob.com/js/js-obj-intro.html\n\nres2https://javascript.info/\n\nMDNhttps://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/\n\n\n学习目标\n基础语法数据类型、变量、函数、事件、运算符、条件语句、循环、正则函数、类let、constprompt、confirm、alertarraw function\n\n语言特性表单、验证API、this、JSON、异步编程、Promise、代码规范DOM、高级、BOM、JS库\n\n开发实战\n\n\n语言本身res2.Data types —  Map and Set\n浏览器相关Window、DOM、BOMres2.Document — 1.3\nHTML事件事件\t描述onchange\tHTML 元素改变onclick\t用户点击 HTML 元素onmouseover\t鼠标指针移动到指定的元素上时发生onmouseout\t用户从一个 HTML 元素上移开鼠标时发生onkeydown\t用户按下键盘按键onload\t浏览器已完成页面的加载更多事件列表: JavaScript 参考手册 - HTML DOM 事件。\n学习过程\n计划\n\n\n整体架构总览 — 阅读书籍&#x2F;课程（输入）\n快速上手 — 官方文档 （输入）\n应用&#x2F;深入细节 — 看实例&#x2F;做项目（输出）\n文档总结 — 做实例还是项目完成之后都要写 - 文档记录要贯穿始终，学到的新东西最好记录一下 （输出）\n\n\n目前做过\n\n\nJavaScript 跟着文档学习了基本语法，部分特性， 基本能读懂，需要依赖文档来写代码。（输入）\n\n\n接下来\n\n\n跟着文档或者视频做一个完整的项目，学习开发流程，系统架构等。（输入）\n找本书看看，技术架构、特性和生态。JavaScript（输入）\n写文档总结一下自己的学习过程，遇到的问题，解决的方法，找到的资源。（输出）\n\n项目经历\nSilly story generator - basic API of JS\nImage gallery - functions - logic and loops\nJS objects\nJS Asynchronous \nClient-side web API\n\n","tags":["编程","编程训练"]},{"title":"生活的意义是什么，人类的未来在哪里？","url":"/2023/02/12/%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BA%BA%E7%B1%BB%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F/","content":""},{"title":"阅读","url":"/2023/02/16/%E9%98%85%E8%AF%BB/","content":"书单\n《The passionate programmer》\n《Soft skills》\n《Designing Data-Intensive Applications》\n\n","tags":["我","读书"]},{"title":"图片上传项目","url":"/2023/02/17/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/","content":"Project Progress（Three steps）\nUI and function of UploaderUI is done, function includes two parts:\n\n\ndrag and drop\n点击上传本地文件\n\n\nUI 上传过程（开始上传和上传完整之前显示）\nUI 上传完成，展示后端响应的图片和链接待做。\n\nDrag and drop 页面两个功能的实现方法\n将文件拖拽到浏览器并传输过程：https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop\n点击按钮打开本地文件夹，并上传文件的方法？ 如何控制上传文件的类型，如何获取上传文件的进度？实现方法：http://doc.ruoyi.vip/ruoyi-vue/document/htsc.html#%E4%B8%8A%E4%BC%A0%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B\n\n前端技术点：\n文件对象的获取，Input type &#x3D; file\n\naxios post请求 请求体头 ：”Content-type”: “multipart&#x2F;form-data”\n\nvue路由， 文件上传时，转换到上传过程页面， 上传完成转换到上传完成页面，之后可以回到 主页上传页面。这三个显示画面之间的转换，最终实现用的是组件之间的状态转换，根据上传的状态转换一个状态， 根据状态展示一个组件。\n\n将子组件的值传递给父组件，利用事件触发，$emit。\n\n\n问题\n如何将子组件的属性值传递给父组件？$emit\n\n一个组件是否可以有两个不同的监听事件？\n\n\n前端 细节实现\n标签\n通过触发事件， 获取到输入的文件\n通过formdata封装文件，放在请求体中，给服务端发送post请求。const uploadForm = document.querySelector(&#x27;.upload&#x27;)uploadForm.addEventListener(&#x27;submit&#x27;, function(e) &#123;   e.preventDefault()   let file = e.target.uploadFile.files[0]   //formdata来保存文件   let formData = new FormData()   formData.append(&#x27;file&#x27;, file)      fetch(&#x27;http://localhost:3000/upload_files&#x27;, &#123;      method: &#x27;POST&#x27;,     //将formdata放入请求体     body: formData   &#125;)   .then(resp =&gt; resp.json())   .then(data =&gt; &#123;      if (data.errors) &#123;         alert(data.errors)      &#125;      else &#123;         console.log(data)      &#125;   &#125;)&#125;)\n\n显示界面的变换\n未选择好要发送的图片之前， 显示图片选择界面\n选择好开始发送，发送中，到发送完成，显示发送过程中界面\n收到服务端回复，显示服务端发送回来的图片URL\n\n后端 实现细节\nuploading image to a static folder in the server\ndownloading image from server with the link\ndisplay list of imagesJava实现资源：https://www.bezkoder.com/spring-boot-image-upload-thymeleaf/文件处理类：MultipartFile\n\nService类实现思路：\n\n设置接收文件路径\n创建文件路径\n保存文件\n\nImageModel：属性： name、URL 用这两个属性来描述一个图片。\nwhat i learnedThis is my First time full stack project experience, first time work with Vue.I learn a new frontend framework, and i build a project with it from scratch.I feel pretty much a sense of accomplishment.\nThere would be more than one solution to approach a project. New technology will make some feature easier to build, but more complexity it brings too.\nA long way to go, i learn some skills of Vue to build the featrues i need in my project, but there is a way more to learn to master Vue. To learn as i need, save time and high effciency.Learn and Build is a good way to learn new techs, as you can’t learn everything before you start to build something.\n","categories":["项目经验"],"tags":["项目经验"]},{"title":"如何开发一个陌生的功能","url":"/2023/02/18/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%99%8C%E7%94%9F%E7%9A%84%E5%8A%9F%E8%83%BD/","content":"资源\n对于陌生的功能，以文件上传为例说明\n\n\n功能的参与者： （参与者为客户端和服务端）\n功能的流程：  用户先在客户端这边选择一个文件，然后以http的post请求的方式发送给服务端；  服务端接收到文件后，在本地创建文件夹并存储文件。\n功能流程中具体可以使用的类库：（使用起来比较方便的语言类库） 前端使用formdata的key&#x2F;value键值对来将file文件存储起来，放入http请求体中， 请求头的类型改为“multipart&#x2F;&#x2F;form-data”； 后端以java为例，使用MultipartFile 对象来接收，后转为File文件对象，将接收到的文件存储在一个文件夹中。\n\n实践\n自己尝试用以上的资源和思路实现这个流程。\n寻找已经实现的实例，参考设计思路和具体实现过程，使用的类库和方法。\n优化重构源代码。\n\n","tags":["软件开发理解","技巧","项目经验"]},{"title":"如何高效技术阅读？","url":"/2023/02/18/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%8A%80%E6%9C%AF%E9%98%85%E8%AF%BB%EF%BC%9F/","content":"总览总览大纲可以获得这个技术的整体架构，能够完整的，系统的了解这个技术。\n深入细节\n找到关键词，带着问题深入阅读相关部分， 并回答自己对于关键词的提问。 What、Why、How。\n有一些技术可能需要动手实践。\n\n参考：https://mvpsheng.github.io/2023/01/11/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%96%B0%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF-%E6%A1%86%E6%9E%B6/\n记录读书笔记回看读书笔记会比翻书更容易帮助回忆一些内容：\n\n自己当时没搞懂的部分\n学到的新概念\n技术的整体架构，应用与替换方案。\n\n","tags":["技巧","阅读"]},{"title":"JavaScript训练","url":"/2023/02/20/JavaScript%E8%AE%AD%E7%BB%83/","content":"一周训练计划Day 1：了解 JavaScript\nJavaScript的基本概念，语言特点在HTML文件中使用JavaScript变量和数据类型：数字、字符串、数组、对象等Day 2：JavaScript流程控制\n条件语句：if&#x2F;else循环语句：for和while了解JavaScript中的布尔值和逻辑运算Day 3：JavaScript函数\n函数的基本概念和定义函数参数的传递方式函数返回值和函数的递归调用Day 4：JavaScript DOM 操作\n了解DOM的概念DOM节点的操作：增加、删除、修改等事件的绑定和响应Day 5：JavaScript面向对象编程\n面向对象编程基本概念JavaScript中的类和对象类的继承和多态Day 6：JavaScript异步编程\n异步编程基本概念JavaScript中的定时器JavaScript中的AJAX操作Day 7：小项目练手\n使用所学知识完成一个简单的小项目，例如：表单验证、图片轮播等。以上是一个初级开发者一周的 JavaScript 入门学习计划，可以适当根据自身情况进行调整和扩展。在学习过程中，结合阅读相关的文档和参考书籍，同时多加实践，加深对 JavaScript 的理解和掌握。\n","tags":["编程"]},{"title":"myunsplash","url":"/2023/02/22/myunsplash/","content":"用户故事\n可以看到添加的图片列表\n可以往图片列表中接入新图片\n可以用标签搜索图片\n将鼠标悬停在照片上时，可以看到标签和删除按钮\n可以删除图片\n\n开发流程\n先设计数据库， 给后端存入数据， 写好后端服务接口 — 添加和展示所有图片接口\n前端调出来所有图片，调整样式\n开发搜索功能、删除\n\n前后端仓库前端：https://github.com/mvpsheng/myunsplash/tree/master后端：https://github.com/mvpsheng/imageUploaderBackend\n图片列表展示功能\n前端需要设计一个图片展示样式，通过get请求获取到图片url数据之后，将图片按照一定的样式展示出来。\n后端需要将图片url存储在数据库中，这样方便进行图片数据的操作。\n\n前端添加图片功能\n前端添加图片通过前端路由进入图片上传模块中， 开始图片上传，\n图片上传成功后，图片存储在后端服务器（文件夹中）上，并且将url存储在服务器数据库中，\n后端返回图片的url地址和图片给前端，前端利用后端返回的url地址将图片显示出来。\n\n删除图片\n前端发送删除请求， 后端从数据库中删除图片的url\n前端中找不到该图片的url判断为不显示。\n\n功能的使用时机：打开主页时，展示图片墙。\n问题：\n后端如何用数据库存储图片？\n\n\n存储图片的路径地址（URL），然后按照文件的路径地址来上传。\n存储图片，用mysql数据类型blob（二进制的数据类型）。\nOSS（阿里云对象存储服务）\n\n\n如何返回数据？前端请求照片墙， 后端返回 图片标签和图片url， 前端根据url展示图片。\n\n为什么不能直接用http://localhost:8080/uploads/%E8%AE%BE%E7%BD%AE.jpeg 这个链接在浏览器中获取SpringBoot应用根目录的资源？（静态资源的访问控制）\n\n\nSpring Boot默认情况下不会将静态资源暴露出去，需要进行相应的配置才能让客户端通过链接访问静态资源。可以在application.properties或application.yml中进行相关配置。以application.properties为例，可以添加以下配置：\n# 配置静态资源文件路径spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,file:/path/to/your/uploads/folder/\n其中&#x2F;path&#x2F;to&#x2F;your&#x2F;uploads&#x2F;folder&#x2F;为存储上传图片的目录路径，需要将其替换为实际的目录路径。这个配置会将Spring Boot的静态资源路径设置为上述几个路径，同时添加上传图片的目录路径，这样Spring Boot就能够将这个路径下的静态资源暴露出去，供客户端访问了。\n注意，如果Spring Boot应用是以jar包形式运行的，那么由于jar包本身是不可写的，需要将上传图片的目录放在jar包之外，否则上传图片的操作可能会失败。\n\n图片选择存在服务端的文件夹中的话，这个文件夹的位置如何确定，这个静态资源如何控制访问权限？\n\n获取图片方式的选择\n自己拼接URL\n通过Resouce类进行获取URL\n\nURL生成方法This URL should contain the API endpoint base URL plus the path to the image file using the unique filename.ImageURL &#x3D; API终端基础URL + 包含文件名的路径\n为什么将图片url存在数据库？Save images in a database and not just in a folder for frontend access.Storing images in a database has the following advantages:\n\nEasy to query - Can fetch images using various filters like date uploaded, category, etc.\nVersioning - Can maintain history of changes made to an image.\nAdditional metadata - Can store additional details about an image like title, description, tags, etc. along with the image data.\nBetter security - Databases typically have more security mechanisms in place to prevent unauthorized access as compared to just storing files in a folder.\nEasier to backup and migrate - Can take backups and migrate a database more easily than just copying files from folders.\n\n","tags":["项目经验"]},{"title":"Vue训练","url":"/2023/02/20/Vue%E8%AE%AD%E7%BB%83/","content":"一周训练计划第一天：\n学习Vue.js的基本概念和核心概念，包括指令、计算属性、组件、生命周期等。\n安装Vue.js，并使用Vue.js创建一个简单的Hello World项目。\n第二天：\n学习Vue.js的组件化开发思想，包括组件的定义、使用、通信和复用等。\n实践一个简单的组件开发案例，并掌握Vue.js组件之间的通信方式。\n第三天：\n学习Vue.js的路由管理功能，包括路由的定义、使用和参数传递等。\n实践一个简单的路由管理案例，并掌握Vue.js路由之间的参数传递。\n第四天：\n学习Vue.js的状态管理功能，包括状态的定义、使用和数据更新等。\n实践一个简单的状态管理案例，并掌握Vue.js状态更新的基本操作。\n第五天：\n学习Vue.js的表单操作功能，包括表单的定义、验证和提交等。\n实践一个简单的表单操作案例，并掌握Vue.js表单验证和提交的基本操作。\n第六天：\n学习Vue.js的动画效果功能，包括动画的定义、使用和过渡效果等。\n实践一个简单的动画效果案例，并掌握Vue.js动画效果的基本操作。\n第七天：\n学习Vue.js的打包和部署功能，包括打包和部署的命令和方法等。\n实践将自己的Vue.js项目打包和部署到线上服务器上。\n以上是一个简单的一周学习计划，可以帮助新入门的Vue学习者快速了解和掌握Vue.js的基本概念和应用，达到独立开发的能力。\n学习路径（输入 - 输出）\n目前做过\n\n\nJavaScript 跟着文档学习了基本语法，部分特性， 基本能读懂，需要依赖文档来写代码。（输入）\nVue.js 跟着官网文档 学习了基本语法特性等，能读懂，能自己简单写，实现一些特性如组件传值等需要依赖文档。（输入）\n尝试用Vue.js做图片上传的前端，虽然基本样子实现了，但是样式很乱，整个项目的文件架构也不知道要怎么组织，所以觉得需要看书或者跟着视频或文档学一个做项目。（输出）\n跟着文档做了一个完整的项目，学习开发流程，系统架构等。（输入）做了一个TODOlist，主要是写组件，然后把组件集成起来。把学习到的新的记录在之后的总结文档中。\n\n\n接下来\n\n\n找本书看看，技术架构、特性和生态。JavaScript - Vue.js（输入）\n写文档总结一下自己的学习过程，输出过程中遇到的问题和困难，解决的方法，找到的资源。（输出）\n\n已经掌握的知识收获\n集成组件开发了一个小的应用。\n学习了一些特性，一个组件是一个对象，可以有data、method、mounted等。\n组件之间的传值、事件触发。\n具备写出来一个简单应用的能力了（过程要看文档，因为还不熟）。\n\n想回头再学学JS和TS。\n问题","tags":["编程"]},{"title":"python训练","url":"/2023/02/20/python%E8%AE%AD%E7%BB%83/","content":"一周训练计划\nDay 1：了解Python\n\nPython的基本概念，语言特点安装Python环境，使用Python的交互式解释器变量和数据类型：数字、字符串、列表、元组、字典等\n\nDay 2：Python流程控制\n\n条件语句：if&#x2F;else循环语句：for和while了解Python中的布尔值和逻辑运算\n\nDay 3：Python函数\n\n函数的基本概念和定义函数参数的传递方式函数返回值和函数的递归调用\n\nDay 4：Python模块\n\n了解Python中的模块和导入方式自定义模块的创建Python常用的内置模块\n\nDay 5：Python面向对象编程\n\n面向对象编程基本概念Python中的类和对象类的继承和多态\n\nDay 6：Python文件操作\n\n了解Python中的文件读写操作打开、关闭、读写文件文件操作的异常处理\n\nDay 7：小项目练手\n\n使用所学知识完成一个简单的小项目，例如：爬取网站信息、数据处理和可视化等。以上是一个初级开发者一周的 Python 入门学习计划，可以适当根据自身情况进行调整和扩展。建议在学习过程中，结合阅读相关的文档和参考书籍，同时多加实践，加深对 Python 的理解和掌握。\n项目开发What project i can build with python in three days as a newcomer, which would also help me a lot to learn more about python?\nAs a newcomer to Python, building a project in three days can be a great way to get hands-on experience and learn more about the language. Here is a project idea that you can complete in three days:\nBuild a To-Do List Web Application using Flask\nThe objective of this project is to build a simple to-do list web application using Flask, a lightweight web framework for Python. Here are the steps to follow:\nDay 1:\n\nInstall Flask and set up a virtual environment for your project.\nCreate a basic Flask application with a home page that displays a welcome message.\nSet up a database to store the to-do list items using SQLAlchemy, a popular Object-Relational Mapping (ORM) library for Python.\nCreate a model for the to-do list items and define the necessary fields.item： content、status、date\n\nDay 2:\n\nCreate a page that displays all the to-do list items from the database.\n\nImplement the functionality to add new to-do list items using a form.\n\nImplement the functionality to edit and delete to-do list items.\n\nStyle the application using CSS to make it look visually appealing.Day 3:\n\nTest the application thoroughly to ensure it is working as expected.\n\nDeploy the application to a hosting platform like Heroku to make it accessible online.\n\nWrite documentation for the application and the code.This project will give you hands-on experience with Flask, SQLAlchemy, Deployment.\n\n\n后端开发\nWeb框架：Web框架是Python后端开发的基础，它提供了处理HTTP请求和响应的核心功能，常用的Web框架有Django、Flask、Tornado、Bottle等。\n\n数据库：数据库是后端开发必不可少的组件，常用的关系型数据库有MySQL、PostgreSQL、SQLite等，非关系型数据库有MongoDB、Redis等。\n\n缓存：缓存是提高Web应用性能的重要组件，常用的缓存系统有Memcached、Redis等。\n\n消息队列：消息队列是一种异步通信机制，常用的消息队列系统有RabbitMQ、ActiveMQ等。\n\nAPI设计和文档：API设计和文档是后端开发的重要组成部分，常用的API设计工具有Swagger、Postman等。\n\nDevOps工具：DevOps工具可以帮助开发者更好地管理项目和部署应用，常用的DevOps工具有Docker、Kubernetes、Git等。\n\n\n如何学习Python后端技术栈：\n\n阅读官方文档和教程：首先可以去各个技术栈的官方网站查看官方文档和教程，学习技术栈的基本概念和用法。\n\n学习开源项目：可以参与一些开源项目，了解实际应用场景和开发过程，提高编程能力和实践经验。\n\n参加培训和在线课程：可以参加一些线下培训或在线课程，学习专业知识和实践经验，与同行交流。\n\n实践和项目经验：通过实践和项目经验不断积累，熟练掌握各项技术栈，提高编程能力和解决问题的能力。\n\n\nflask训练资源：https://flask.net.cn/installation.html#installation\n","tags":["编程"]},{"title":"前端概念认知","url":"/2023/02/20/%E5%89%8D%E7%AB%AF%E6%A6%82%E5%BF%B5%E8%AE%A4%E7%9F%A5/","content":"单页面应用和多页面应用分别是指什么，两者有什么区别？在前端开发中，单页面应用（Single-Page Application，SPA）和多页面应用（Multiple-Page Application，MPA）是两种不同的应用架构。\n单页面应用（SPA）是指在同一个页面中加载所有必要的HTML、CSS、JavaScript，并且只在必要时使用AJAX从服务器加载数据。当用户与应用程序交互时，JavaScript会动态地更新页面内容，而不是通过服务器端渲染。 SPA 通常使用一些流行的 JavaScript 框架和库，如 React、Angular、Vue等。\n多页面应用（MPA）是指每个页面都是独立的，需要通过向服务器请求新页面来加载内容。页面跳转时会重新加载整个页面，这通常会导致性能下降。MPA通常使用传统的服务器端渲染技术，如Java Servlet、PHP等。\nSPA与MPA相比，具有以下特点：\n用户体验更加流畅，页面切换不需要重新加载，操作更加快捷。前后端分离，使得前端和后端可以独立开发、测试和部署。前端负责UI渲染，后端负责提供数据API接口，各司其职，便于维护和升级。SPA相对来说更加适合移动端和响应式设计。要深入学习前端开发中的单页面应用和多页面应用，可以学习以下内容：\n学习常用的SPA框架，如React、Angular、Vue等，了解其基本原理、使用方法和常见应用场景。学习前端路由的使用和实现，了解如何通过路由实现单页面应用。学习RESTful API的设计和使用，了解如何通过API与后端交互。学习前端性能优化的技巧，了解如何提高SPA的性能和用户体验。学习前后端分离的设计思想和技术实现，了解如何构建可维护和可扩展的SPA应用。\n","tags":["开发经验"]},{"title":"后端概念认知","url":"/2023/02/20/%E5%90%8E%E7%AB%AF%E6%A6%82%E5%BF%B5%E8%AE%A4%E7%9F%A5/","content":"数据存储可扩展性性能优化"},{"title":"pursue work-life balance","url":"/2023/02/23/pursue-work-life-balance/","content":"whyAfter i long day of working on sth, i feel exhausted. I am pursuing a work life balance. Because i am passionate, when i work on sth that make me excited, i would speed too much time on it.And i don’t feel anything else utill my body told me to rest. For a long run, i have to do so.\nhow\nset goal &#x2F; deadline or a task before start to do sthWhen you have a goal, you know what you could accomplish.The deadline can tell when to stop.A task that you can finish.\n\ngive your self reward when you do soWhen you accomplish sth, give your self a reward, you’ll remember that sense of accomplishment;When you stop at your deadline, take a break, enjoy your self with the time that you are out of your business.So that you could be more productive or energetic  in the next time.\n\n\n","tags":["技巧","English"]},{"title":"DDIA_Reading_Notes","url":"/2023/02/25/DDIA-Reading-Notes/","content":"Time\n2023&#x2F;02&#x2F;25（How time flies!）\n\nStructure of the bookThis book is divided into three parts.\n\nPart I.   Fundations of Data Systems.-discuss the fundamental ideas that underpin the design of data-intensive applications.\nPart II.  Distributed Data.-we move from data stored on one machine to data that is distributed across multiple machines.\nPart III. Derived Data.-we discuss systems that derive some datasets from other datasets.\n\nCurrent reading progressGeneral ideas of part IThe first four chapters go through the fundamental ideas that apply to all data systems, whether running on a single machine or distributed across a cluster ofmachines:\n\nChapter 1 introduces the terminology and approach that we’re going to use throughout this book. It examines what we actually mean by words like reliability, scalability, and maintainability, and how we can try to achieve these goals.\n\nChapter 2 compares several different data models and query languages—the most visible distinguishing factor between databases from a developer’s point ofview. We will see how different models are appropriate to different situations.\n\nChapter 3 turns to the internals of storage engines and looks at how databases layout data on disk. Different storage engines are optimized for different workloads,and choosing the right one can have a huge effect on performance.\n\nChapter 4 compares various formats for data encoding (serialization) and especially examines how they fare in an environment where application requirements change and schemas need to adapt over time.\n\n\nPart I - Chapter 1A data-intensive application is typically built from standard building blocks that pro‐vide commonly needed functionality. For example, many applications need to:\n\nStore data so that they, or another application, can find it again later (databases)\nRemember the result of an expensive operation, to speed up reads (caches)\nAllow users to search data by keyword or filter it in various ways (search indexes)\nSend a message to another process, to be handled asynchronously (stream pro‐cessing)\nPeriodically crunch a large amount of accumulated data (batch processing)\n\nReliabilityThe system should continue to work correctly (performing the correct function at the desired level of performance) even in the face of adversity (hardware or soft‐ware faults, and even human error).\nFor software, typical expectations include:\n\nThe application performs the function that the user expected.\nIt can tolerate the user making mistakes or using the software in unexpected ways.\nIts performance is good enough for the required use case, under the expected load and data volume.\nThe system prevents any unauthorized access and abuse.\n\nScalabilityAs the system grows (in data volume, traffic volume, or complexity), there should be reasonable ways of dealing with that growth.\n\nMain concepts:\n\n\nDescribing Load :Load can be described with a few numbers which we call load parameters. The best choice of parameters depends on the architecture of your system: it may be requests per second to a webserver, the ratio of reads to writes in a database, the number of simultaneously active users in a chat room, the hit rate on a cache, or something else. Perhaps the averagecase is what matters for you, or perhaps your bottleneck is dominated by a small number of extreme cases.\n\nDescribing Performance\n\n\nSome systems are elastic, meaning that they can automatically add computing resources when they detect a load increase, whereas other systems are scaled manually (ahuman analyzes the capacity and decides to add more machines to the system).An elastic system can be useful if load is highly unpredictable, but manually scaled systems are simpler and may have fewer operational surprises\nMaintainabilityOver time, many different people will work on the system (engineering and operations, both maintaining current behavior and adapting the system to new usecases), and they should all be able to work on it productively.  pay particular attention to three design principles for software systems will hopefully minimize pain during maintenance, and thus avoid creating legacy software ourselves. \n\nOperabilityMake it easy for operations teams to keep the system running smoothly.\nSimplicityMake it easy for new engineers to understand the system, by removing as much complexity as possible from the system. (Note this is not the same as simplicity of the user interface.)\nEvolvabilityMake it easy for engineers to make changes to the system in the future, adapting it for unanticipated use cases as requirements change. Also known as extensibility, modifiability, or plasticity.\n\nPart I - Chapter 2 - Data Models and Query LanguagesThe limits of my language mean the limits of my world.    —Ludwig Wittgenstein, Tractatus Logico-Philosophicus (1922)Can not agree more! Keep learning, language is not being a barrier!Data models are perhaps the most important part of developing software, because they have such a profound effect: not only on how the software is written, but also onhow we think about the problem that we are solving.\nWhat’s good?\nTechnology can be used for good, make underrepresented people’s voices heard, to create opportunities for everyone, and avert disasters.\nFortunately, behind the rapid changes in technology, there are enduring principlesthat remain true, no matter which version of a particular tool you are using. If youunderstand those principles, you’re in a position to see where each tool fits in, how tomake good use of it, and how to avoid its pitfalls.\n\nQ&amp;A(General ideas about this book!)What is Data-intensive application?An application data-intensive if data is its primary challenge– the quantity of data, the complexity of data, or the speed at which it is changing–as opposed to compute-intensive, where CPU cycles are the bottleneck.\nWhat will you learn from this book?• You want to learn how to make data systems scalable, for example, to supportweb or mobile apps with millions of users.\n• You need to make applications highly available (minimizing downtime) andoperationally robust.\n• You are looking for ways of making systems easier to maintain in the long run,even as they grow and as requirements and technologies change.\n• You have a natural curiosity for the way things work and want to know whatgoes on inside major websites and online services. This book breaks down theinternals of various databases and data processing systems, and it’s great fun toexplore the bright thinking that went into their design.\nScope of this book?Instead we discuss the various principles and trade-offs that are fundamental to data systems, and we explore the different design decisions taken by different products.\nReferences https://github.com/ept/ddia-references\n","tags":["English","阅读"]},{"title":"git_Cheatsheet","url":"/2023/02/27/git-Cheatsheet/","content":"git 主分支保护配置git冲突避免工作前先pull最新代码， 修改代码， commit，push之前再pull确保最新代码，再push。过程中跟团队成员沟通， 确保自己跟进最新状态，如果还是冲突了就手动解决冲突。\n如何贡献不要加入没有用的代码。\n提交pr时候说明修改目的，修改细节，并且测试通过。\n"},{"title":"CodeGym项目","url":"/2023/03/01/CodeGym%E9%A1%B9%E7%9B%AE/","content":"起源交流让技术学习变得容易，CodeGym就是让有激情的程序员相互学习和交流的平台。\n系统功能\n用户基本信息展示\n\n\n基本数据结构与算法能力（链表、数组；动态规划、回溯）\n技术栈（Java、SpringBoot、MySQL）\n项目经验（商城、博客）\n自己想要提升&#x2F;新学的技能（一个算法能力、想做的一个项目，一个想学的技术）\n\n\n发起活动想要参与活动的人都是活动发起人， 选择三种活动类型中的一个或多个（如果同时选择多个，时间可以连续，但不能重合），用户填充相关信息后，活动即可发起，等待匹配。\n\n匹配活动系统会对匹配条件合适的用户进行匹配，匹配成功后会发送订阅通知。\n\n\n活动的三种类型三种活动相关信息包含：（活动类型、自己可以参与的时间，参与的时长）\n\n面试中的算法题准备特定信息： 匹配的一方是想要被测试，另一方是想要体验面试官或者想锻炼自己面试官的能力。\n\n交流项目经验参与者必须具备项目开发经验\n\n模拟面试\n\n\n","tags":["项目经验"]},{"title":"本地图书馆项目","url":"/2023/03/01/%E6%9C%AC%E5%9C%B0%E5%9B%BE%E4%B9%A6%E9%A6%86%E9%A1%B9%E7%9B%AE/","content":"资源https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs/Tutorial_local_library_website通过构建项目的过程学习express框架核心知识以及项目架构，也学习了web开发到部署的流程。\n","categories":["项目经验"],"tags":["项目经验"]},{"title":"最近在做什么003","url":"/2023/02/28/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88003/","content":"为什么写因为觉得最近做的事情，觉得看到自己思考的维度在变化很有意思，很有意义。\n在做什么\n做研究（一个具体的需求如何实现，为什么一些项目很受欢迎）\n写文档 （对做过的项目记录思考的过程，实现方案的权衡）\n合作项目开发\n\n收获与变化\n初期的困惑前段时间觉得自己独立开发很难表达出自己的想法，因为我没怎么学过前端，头疼，于是找队友。前端的队友帮我实现页面，我来做后端逻辑。初期效果是满意的。 逐渐领悟到合作中沟通来明确项目需求，沟通解决方案。 后来就觉得界面想要更完善，有些小的东西想优化，又不想麻烦别人。于是就开始自学前端的开发技术。\n\n动手学习好在Java学了两年，看了很多书，文档、视频，项目。没有什么工作经验，但是阅历丰富了。入手JS、Node很快。前端三剑客很快就能写出点东西了。连之前很头疼的CSS也逐渐开始有感觉了。\n\n遇到问题做了一些响应式的页面。于是入手全栈开发。就想着用框架也许可以更优雅，更高效的实现想要的样子，入手Vue，因为之前合作的朋友是擅长Vue，方便学习问问题。 第一天感觉惊讶，Vue教学很细， 逐个的去学习，学完了也没有能构建起一个项目的逻辑思维。 \n\n解决问题的过程与思考探索我做这件事情的终极目标是什么，我为了能自己独立开发， 并不意味我需要把这个技术掌握的多么全面，至少现在不需要， 所以我只需要掌握我需要用到的部分就够了。\n\n解决问题于是换一个思路，我要做一个项目， 根据项目需求去针对性的学习。这个方法很好， 有了需求，我就可以定义问题， Vue的什么可以用来实现我这个需求，然后我如何去用这个模块。 即解决了问题， 还学了新技术。于是我对于新技术的学习也就有了新的思路， 按需学习，而不是刚上来就试图学完所有的概念，这很枯燥也很花时间，要是有一些不好理解的内容，还容易打击自信心和积极性。\n\n总结 方法按需学习的重点是 理解需求、定义问题，分析问题， 解决方案， 执行方案， 总结。\n\n思考程序员写代码很重要， 但是写好的代码 需要好的思维，需要前期的投入去分析需求，做研究，思考方案，直到最终实现。写代码之前的流程都很重要，这些很多是我之前不了解的领域，这些是进步和学习的过程，写代码是将自己已有的思路表达出来。\n\n\n","tags":["最近在做什么"]},{"title":"如何学习一个项目","url":"/2023/03/13/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/","content":"为什么学习项目为了提升自己做项目的能力：\n\n架构设计\n技术选型\n开发工具\n实现策略\n项目管理\n\n方法\n仿着做一个\n阅读项目文档，运行部署，debug\n\n不同阶段\n初阶跟着文档或视频学项目 -复制或自己写，完成后要总结学到的东西：设计思路， 项目架构， 代码规范， 语言&#x2F;框架特性\n\n中高阶自己设计实现项目全流程，记录过程中的问题，解决文档，参考相关的开源项目，对自己的设计优化。\n\n\n","tags":["技巧"]},{"title":"认证项目","url":"/2023/03/13/%E8%AE%A4%E8%AF%81%E9%A1%B9%E7%9B%AE/","content":"目标\n对用户进行认证， 用户可以自己登录注册，\n也可使用第三方登录注册例如GitHub。\n用户可以登出\n用户可以查看、编辑自己的信息，并上传自己的头像照片\n\n资源https://devchallenges.io/challenges/N1fvBjQfhlkctmwj1tnw\n","categories":["项目经验"],"tags":["项目经验"]},{"title":"聊天项目","url":"/2023/03/13/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/","content":"目标\nUser story: By default, I am in the Welcome channel\nUser story: I can create a new channel with a name and a description\nUser story: I can select a channel of my choice\nUser story: When I can select a channel, I am added as a member of the channel\nUser story: I can see a member of the channel\nUser story: I can send a message\nUser story: I can see other people’s messages\nUser story(optional): I can search for a group\n\n资源https://devchallenges.io/challenges/UgCqszKR7Q7oqb4kRfI0\n","categories":["项目经验"],"tags":["项目经验"]},{"title":"CSS训练","url":"/2023/03/13/CSS%E8%AE%AD%E7%BB%83/","content":"资源https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/Getting_started\n游戏中学习"}]